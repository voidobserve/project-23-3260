C51 COMPILER V9.60.7.0   RF_RECORD                                                         05/06/2024 16:56:06 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE RF_RECORD
OBJECT MODULE PLACED IN .\Release\Objects\RF_Record.obj
COMPILER INVOKED BY: D:\AppData\keil-C51\C51\BIN\C51.EXE ..\..\User\RF_Record.c LARGE OPTIMIZE(8,SPEED) BROWSE INTVECTOR
                    -(0X000C) INCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listin
                    -gs\RF_Record.lst) OBJECT(.\Release\Objects\RF_Record.obj)

line level    source

   1          // RF-315MHzԴ
   2          #include "RF_Record.h"
   3          #include "my_gpio.h"
   4          #include "send_key.h"
   5          #include "flash.h" // Ƭϵflashز
   6          
   7          #define FLASH_DEVICE_START_ADDR 0x00 // ƬflashУrf豸ַʼַ
   8          unsigned int device_addr[10] = {0};      // rf豸ַ
   9          unsigned char device_num = 0;            // ¼Ѿŵַĸжٸ豸
  10          
  11          static volatile int high_level_flag = 0; // Ƿյһθߵƽźŵı־λ
  12          static volatile int tmr0_cnt = 0;                // ʱжϷУʹõļֵ
  13          static volatile int high_level_time = 0; // 涨ʱļֵʱʱ䣩ֹʱظʱ
             -tmr0_cntݸ
  14          
  15          volatile unsigned int rf_data = 0; // ڴŽյ24λ
  16          
  17          volatile int recv_rf_flag = 0; // Ƿյrfźŵı־λ
  18          
  19          // RFINųʼRFųʼ
  20          // Ҳʹõ˶ʱTMR0óÿ100usҲһжϣ20usú󣬶ʱTMR0ǹ
             -յ
  21          void RFIN_Init(void)
  22          {
  23   1              // int tmr0_cnt_time = 100 / 3; // ʱTMR0ļڣ100usҲһж
  24   1              short tmr0_cnt_time = 1000 / 3; // ʱTMR0ļڣ100usҲһжϣжϵ40us
             -ǵԳģunsigned short
  25   1      
  26   1              // P0_2Ϊģʽ
  27   1              P0_MD0 &= ~GPIO_P02_MODE_SEL(0x01);
  28   1              // P0_2Ϊ
  29   1              P0_PU |= GPIO_P02_PULL_UP(0x01);
  30   1              // P0_2Ϊʵָգնȡߡ͵ƽ
  31   1              P0_PD |= GPIO_P02_PULL_PD(0x01);
  32   1      
  33   1              __SetIRQnIP(P0_IRQn, P0_IQn_CFG);       // жȼ
  34   1              __EnableIRQ(P0_IRQn);                           // ʹж
  35   1              IE_EA = 1;                                                      // ʹܿ
  36   1              P0_IMK |= GPIO_P02_IRQ_MASK(0x01);      // P02ж
  37   1              P0_TRG0 &= ~GPIO_P02_TRG_SEL(0x03); // P02Ϊ˫ش
  38   1      
  39   1              // öʱ¼RFյĸߵƽʱ
  40   1              __SetIRQnIP(TMR0_IRQn, TMR0_IQn_CFG); // жȼTMR0
  41   1      
  42   1              TMR0_CONL &= ~TMR_PRESCALE_SEL(0x03); // TMR0ԤƵüĴ
  43   1              TMR0_CONL |= TMR_PRESCALE_SEL(0x04);  // TMR0ԤƵΪ16Ƶ48MHz / 16 = 3MHzԼ3usһ
  44   1              TMR0_CONL &= ~TMR_MODE_SEL(0x03);         // TMR0ģʽüĴ
  45   1              TMR0_CONL |= TMR_MODE_SEL(0x01);          // TMR0ģʽΪģʽHIRCм
  46   1      
  47   1              TMR0_CONH &= ~TMR_PRD_PND(0x01); // TMR0ļ־λʾδɼ
  48   1              TMR0_CONH |= TMR_PRD_IRQ_EN(1);  // ʹTMR0ļж
  49   1      
  50   1              // TMR0ļ
C51 COMPILER V9.60.7.0   RF_RECORD                                                         05/06/2024 16:56:06 PAGE 2   

  51   1              TMR0_PRL = tmr0_cnt_time % 255;
  52   1              TMR0_PRH = tmr0_cnt_time / 255;
  53   1      
  54   1              // TMR0ļֵ
  55   1              TMR0_CNTL = 0;
  56   1              TMR0_CNTH = 0;
  57   1      
  58   1              TMR0_CONL &= ~(TMR_SOURCE_SEL(0x07)); // TMR0ʱԴüĴ
  59   1              // TMR0_CONL |= TMR_SOURCE_SEL(0x02);     // TMR0ʱԴΪ48MHzHIRCغ½
  60   1              // TMR0_CONL |= TMR_SOURCE_SEL(0x07); // TMR0ʱԴʹϵͳʱ
  61   1              TMR0_CONL |= TMR_SOURCE_SEL(0x05); // TMR0ʱԴκʱ
  62   1                                                                                 // __EnableIRQ(TMR0_IRQn);                      // ʹж
  63   1      
  64   1              __DisableIRQ(TMR0_IRQn); // ж
  65   1      }
  66          
  67          // TMR0жϷ
  68          void TIMR0_IRQHandler(void) interrupt TMR0_IRQn
  69          {
  70   1              // жIPɾ
  71   1              __IRQnIPnPush(TMR0_IRQn);
  72   1      
  73   1              // ---------------- û -------------------
  74   1      
  75   1              // ж
  76   1              if (TMR0_CONH & TMR_PRD_PND(0x1))
  77   1              {
  78   2                      TMR0_CONH |= TMR_PRD_PND(0x1); // pending
  79   2      
  80   2                      // TMR0ļֵ
  81   2                      TMR0_CNTL = 0;
  82   2                      TMR0_CNTH = 0;
  83   2      
  84   2                      tmr0_cnt++; // ÿ80usÿ120usһ
  85   2              }
  86   1      
  87   1              // ˳жIPɾ
  88   1              __IRQnIPnPop(TMR0_IRQn);
  89   1      }
  90          
  91          // P0жϷ
  92          void P0_IRQHandler(void) interrupt P0_IRQn
  93          {
  94   1              // Px_PNDĴдκֵ־λ
  95   1              u8 p0_pnd = P0_PND;
  96   1      
  97   1              static volatile int i = 0; // ֵ¼ǰյλ
  98   1      
  99   1              // жIPɾ
 100   1              __IRQnIPnPush(P0_IRQn);
 101   1              __DisableIRQ(P0_IRQn); // IOж
 102   1      
 103   1              // ---------------- û -------------------
 104   1      
 105   1              if (p0_pnd & GPIO_P02_IRQ_PNG(0x1))
 106   1              {
 107   2                      // джϷĴ
 108   2      
 109   2                      // ŵǰĵƽ/رնʱTMR0¼һߵƽźŵĳʱ
 110   2                      if (RFIN == 1)
 111   2                      {
 112   3                              // ʱǸߵƽ򿪶ʱTMR0ʼ¼ߵƽʱ
C51 COMPILER V9.60.7.0   RF_RECORD                                                         05/06/2024 16:56:06 PAGE 3   

 113   3      
 114   3                              // TMR0ļֵ
 115   3                              TMR0_CNTL = 0;
 116   3                              TMR0_CNTH = 0;
 117   3      
 118   3                              tmr0_cnt = 0; // ߵƽֵ
 119   3      
 120   3                              // ¸TMR0ʱ
 121   3                              TMR0_CONL &= ~(TMR_SOURCE_SEL(0x07)); // TMR0ʱԴüĴ
 122   3                              TMR0_CONL |= TMR_SOURCE_SEL(0x07);        // TMR0ʱԴʹϵͳʱ
 123   3      
 124   3                              __EnableIRQ(TMR0_IRQn); // ʹж
 125   3                      }
 126   2                      else
 127   2                      {
 128   3                              // ʱǸߵƽرնʱTMR0ߵƽʱ
 129   3      
 130   3                              high_level_time = tmr0_cnt; // һθߵƽʱ
 131   3      
 132   3                              // TMR0ṩʱӣֹͣ
 133   3                              TMR0_CONL &= ~(TMR_SOURCE_SEL(0x07)); // TMR0ʱԴüĴ
 134   3                              TMR0_CONL |= TMR_SOURCE_SEL(0x05);        // TMR0ʱԴκʱ
 135   3      
 136   3                              // TMR0ļֵ
 137   3                              TMR0_CNTL = 0;
 138   3                              TMR0_CNTH = 0;
 139   3                              tmr0_cnt = 0; // ߵƽֵ
 140   3      
 141   3                              __DisableIRQ(TMR0_IRQn); // رTMR0ж
 142   3      
 143   3                              high_level_flag = 1; // һθߵƽʱ¼ɣӦı־λһ
 144   3                      }
 145   2      
 146   2                      // жϷнн
 147   2                      if (high_level_flag)
 148   2                      {
 149   3                              // յһĸߵƽ960us"1"320us"0"
 150   3                              high_level_flag = 0; // ־λ
 151   3      
 152   3                              /*
 153   3                              // дĲȶԻఴΰͻִֵּᷢ
 154   3                              // rf_data <<= 1; // ڴŽ24λݵıһλ
 155   3                              // i++;
 156   3                              */
 157   3      
 158   3                              // жϸߵƽʱ䣬ǷϷΧ
 159   3                              if (high_level_time < 2)
 160   3                              {
 161   4                                      // ߵƽʱС160us  С240us˵յЧź
 162   4                                      rf_data = 0;
 163   4                                      i = 0;
 164   4                              }
 165   3                              else if (high_level_time >= 2 && high_level_time <= 4)
 166   3                              {
 167   4                                      // յ"0"
 168   4                                      rf_data &= ~1;
 169   4                                      i++;
 170   4      
 171   4                                      if (i != 24)
 172   4                                      {
 173   5                                              rf_data <<= 1; // ڴŽ24λݵıһλ
 174   5                                      }
C51 COMPILER V9.60.7.0   RF_RECORD                                                         05/06/2024 16:56:06 PAGE 4   

 175   4                              }
 176   3                              else
 177   3                              {
 178   4                                      // յ"1"
 179   4                                      rf_data |= 1;
 180   4                                      i++;
 181   4                                      if (i != 24)
 182   4                                      {
 183   5                                              rf_data <<= 1; // ڴŽ24λݵıһλ
 184   5                                      }
 185   4                              }
 186   3      
 187   3                              if (i >= 24)
 188   3                              {
 189   4                                      // 24λݣ˵һν
 190   4                                      recv_rf_flag = 1;
 191   4                                      i = 0;
 192   4      
 193   4                                      // Ҳǰȶrf_dataƣrf_dataᶪʧ
 194   4                              }
 195   3                      }
 196   2              }
 197   1      
 198   1              P0_PND = p0_pnd; // P2жϱ־λдκֵ־λ
 199   1      
 200   1              // -------------------------------------------------
 201   1              __EnableIRQ(P0_IRQn); // ʹIOж
 202   1              // ˳жIPɾ
 203   1              __IRQnIPnPop(P0_IRQn);
 204   1      }
 205          
 206          // ǷյRFźţӦп
 207          void rf_recv(void)
 208          {
 209   1              if (recv_rf_flag)
 210   1              {
 211   2                      // ɹ24λ
 212   2                      recv_rf_flag = 0;
 213   2      
 214   2                      // __DisableIRQ(P0_IRQn); // IOж
 215   2      
 216   2                      // send_keyval(rf_data & 0xFF);
 217   2      
 218   2      #if 0 // ͨĴ
                        // p11_send_data_8bit_msb(rf_data & 0x0F);
              
                              // ǰ󶼼Ӹ1msźţ۲
                              P11 = 0;
                              delay_ms(1);
                              P11 = 1;
                              delay_ms(1);
                              // p11_send_data_8bit_msb(rf_data); // 
                              p11_send_data_16bit_msb(rf_data); // 
                              P11 = 1;
                              delay_ms(1);
                              P11 = 0;
                              delay_ms(1);
              
                              rf_data = 0; // ɺյ
                                                       // delay_ms(200); // ʱҪǷֹͣشжϣºյݲ׼ȷ
              #endif
 236   2      
C51 COMPILER V9.60.7.0   RF_RECORD                                                         05/06/2024 16:56:06 PAGE 5   

 237   2      #if 1 // ͨĴ
 238   2      
 239   2                      // жϵַԲ
 240   2                      if ((rf_data & (~0x0F)) == (unsigned int)0xF0B480) // ıȽϱҪǿת
 241   2                      {
 242   3                              switch (rf_data & 0x0F) // жϽյĵλλǼֵ
 243   3                              {
 244   4                              case KEY_RF315_A: // ңA
 245   4                                      send_keyval(KEY_RF315_A);
 246   4                                      break;
 247   4      
 248   4                              case KEY_RF315_B: // ңB
 249   4                                      send_keyval(KEY_RF315_B);
 250   4                                      break;
 251   4      
 252   4                              case KEY_RF315_C: // ңC
 253   4                                      send_keyval(KEY_RF315_C);
 254   4                                      break;
 255   4      
 256   4                              case KEY_RF315_D: // ңD
 257   4                                      send_keyval(KEY_RF315_D);
 258   4                                      break;
 259   4      
 260   4                              case KEY_RF315_E: // ңE
 261   4                                      send_keyval(KEY_RF315_E);
 262   4                                      break;
 263   4      
 264   4                              case KEY_RF315_F: // ңF
 265   4                                      send_keyval(KEY_RF315_F);
 266   4                                      break;
 267   4                              }
 268   3                      }
 269   2      
 270   2      #endif
 271   2      
 272   2                      // __EnableIRQ(P0_IRQn); // ʹIOж
 273   2              }
 274   1      }
 275          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    593    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     33    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
