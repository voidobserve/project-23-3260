C51 COMPILER V9.60.7.0   TK_USER                                                           11/12/2024 17:21:53 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE TK_USER
OBJECT MODULE PLACED IN .\Release\Objects\tk_user.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\tk_user.c LARGE OPTIMIZE(8,SPEED) BROWSE INTVECTOR(0X000C) IN
                    -CDIR(..\..\Libraries\Include;..\..\Hardware;..\..\User;..\..\User\lib) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Li
                    -stings\tk_user.lst) OBJECT(.\Release\Objects\tk_user.obj)

line level    source

   1          /**
   2           ******************************************************************************
   3           * @file    User/tk_user.c
   4           * @author  HUGE-IC Application Team
   5           * @version V1.0.0
   6           * @date    05-20-2022
   7           * @brief   Main program body
   8           ******************************************************************************
   9           * @attention
  10           *
  11           * <h2><center>&copy; COPYRIGHT 2022 TAIXIN-IC</center></h2>
  12           *
  13           *
  14           *
  15           ******************************************************************************
  16           */
  17          
  18          /* Includes ------------------------------------------------------------------*/
  19          #include <stdio.h>
  20          #include "include.h"
  21          #include "my_config.h"
  22          
  23          /** @addtogroup Template_Project
  24           * @{
  25           */
  26          
  27          /* Private typedef -----------------------------------------------------------*/
  28          /* Private define ------------------------------------------------------------*/
  29          /* Private macro -------------------------------------------------------------*/
  30          /* Private variables ---------------------------------------------------------*/
  31          /* Private function prototypes -----------------------------------------------*/
  32          /* Private functions ---------------------------------------------------------*/
  33          
  34          /**
  35           * @brief  Touchkey  debug uart init function
  36           * @param  None
  37           * @retval None
  38           */
  39          // xdata u16 led_data[1];                           // LED显示buff
  40          #define LED_DIS_FREQ (1000000 / 16 / 8 / 60 - 1) // 一个CON的显示时间60Hz    60-1=1M/(LED_COMCON*16*LED_TI
             -ME_CON)
  41          
  42          unsigned int xdata display_data = 0;
  43          
  44          /**
  45           * @brief  调试接口IO初始化函数.
  46           * @param  None
  47           * @retval None
  48           */
  49          #if TK_DEBUG_EN
              void debug_gpio_config(void)
              {
              #if 1
C51 COMPILER V9.60.7.0   TK_USER                                                           11/12/2024 17:21:53 PAGE 2   

                  P2_MD0 &= ~GPIO_P21_MODE_SEL(0x03);
                  P2_MD0 |= GPIO_P21_MODE_SEL(0x01);
                  FOUT_S21 = GPIO_FOUT_UART1_TX;
              #else
                  P2_MD1 &= ~GPIO_P27_MODE_SEL(0x03);
                  P2_MD1 |= GPIO_P27_MODE_SEL(0x01);
                  FOUT_S27 = GPIO_FOUT_UART1_TX;
              #endif
              }
              #endif
  63          
  64          /**
  65           * @brief  用户代码循环执行函数接口.（触摸按键扫描函数接口）
  66           * @param  None
  67           * @retval None
  68           */
  69          #define send_sp (100)
  70          void user_handle(void)
  71          {
  72   1          volatile unsigned long int KeyOnOutput = __tk_key_flag; // __tk_key_flag单次按键标志
  73   1      
  74   1          static volatile unsigned long int KeyOld = 0; // 用于存放长按时，对应的按键
  75   1      
  76   1          // 是否长按的标志，0--否，1--是
  77   1          // 需要保存长按的状态，表示定时器一直在发送键值
  78   1          static unsigned char long_touch_flag = 0; // 上一次扫描到的按键是否为长按的标志
  79   1      
  80   1          static volatile u32 cnt = 0; // 长按计数值
  81   1      
  82   1          u32 i = 0; // 循环计数值
  83   1      
  84   1          u16 send_data = 0; // 要发送的带有键值的数据
  85   1      
  86   1          if (KeyOnOutput && 0 == long_touch_flag && cnt < TK_LONG_KEY_TIME) // 如果有按键按下（并且之前扫描到的
             -不是长按）
  87   1          {
  88   2              // 通过循环判断是否为长按
  89   2              for (i = 0; i < 500000; i++) // 实际上用不到这么大的数字，到了设定的长按时间就会退出
  90   2              {
  91   3                  // 按键扫描函数，使用了库里面的接口（闭源库）
  92   3                  // 这个函数会更新__tk_key_flag的值
  93   3                  delay_ms(10);
  94   3                  __tk_scan();
  95   3      
  96   3                  if (KeyOnOutput == __tk_key_flag)
  97   3                  {
  98   4                      // 如果按键键值一致，说明按键一直被按下，未松开
  99   4                      cnt++;
 100   4                  }
 101   3                  else
 102   3                  {
 103   4                      // 如果按键键值不一致或是松开了按键
 104   4                      // cnt = 0;
 105   4                      break;
 106   4                  }
 107   3                  
 108   3                  if (cnt > TK_LONG_KEY_TIME) // 如果长按超过了这里设置的时间
 109   3                  {
 110   4                      long_touch_flag = 1; // 标记为长按
 111   4                      break;
 112   4                  }
 113   3              }
C51 COMPILER V9.60.7.0   TK_USER                                                           11/12/2024 17:21:53 PAGE 3   

 114   2      
 115   2              if (cnt > TK_LONG_KEY_TIME)
 116   2              {
 117   3                  long_touch_flag = 1; // 标记为长按
 118   3              }
 119   2              else
 120   2              {
 121   3                  // 如果是短按
 122   3                  cnt = 0; // 清除长按的计数值
 123   3      
 124   3                  // 判断当前触摸的键值，做对应的操作
 125   3                  if (TK_CH24_VALIB == KeyOnOutput)
 126   3                  {
 127   4                      // 如果KEY1被触摸
 128   4                      for (i = 0; i < send_sp; i++)
 129   4                      {
 130   5                          delay_ms(1);
 131   5                          __tk_scan();
 132   5                          KeyOnOutput = __tk_key_flag;
 133   5      
 134   5                          if (TK_CH24_VALIB == KeyOnOutput)
 135   5                          {
 136   6                              // 如果检测到是同一个按键按下，说明是双击
 137   6                              // 等待手指松开按键，不然发送完带有双击状态的键值后会再发送一次单击状态的键值
 138   6                              while (0 != KeyOnOutput)
 139   6                              {
 140   7                                  __tk_scan();
 141   7                                  KeyOnOutput = __tk_key_flag;
 142   7                              }
 143   6      #if USE_MY_DEBUG
                                      printf("k1 double press\n");
              #endif
 146   6                              send_status_keyval(KEY_PRESS_DOUBLECLICK, TOUCH_KEY1);
 147   6                              return;
 148   6                          }
 149   5                      }
 150   4      
 151   4      // 如果不是同一个按键按下或是没有值，说明是短按
 152   4      #if USE_MY_DEBUG
                              printf("k1 press\n");
              #endif
 155   4                      send_status_keyval(KEY_PRESS_SHORT, TOUCH_KEY1); // 发送带有状态的键值
 156   4                  }
 157   3                  else if (TK_CH25_VALIB == KeyOnOutput)
 158   3                  {
 159   4                      // 如果KEY2被触摸
 160   4                      for (i = 0; i < send_sp; i++)
 161   4                      {
 162   5                          delay_ms(1);
 163   5                          __tk_scan();
 164   5                          KeyOnOutput = __tk_key_flag;
 165   5      
 166   5                          if (TK_CH25_VALIB == KeyOnOutput)
 167   5                          {
 168   6                              // 如果检测到是同一个按键按下，说明是双击
 169   6                              // 等待手指松开按键，不然发送完带有双击状态的键值后会再发送一次单击状态的键值
 170   6                              while (0 != KeyOnOutput)
 171   6                              {
 172   7                                  __tk_scan();
 173   7                                  KeyOnOutput = __tk_key_flag;
 174   7                              }
 175   6      #if USE_MY_DEBUG
C51 COMPILER V9.60.7.0   TK_USER                                                           11/12/2024 17:21:53 PAGE 4   

                                      printf("k2 double press\n");
              #endif
 178   6                              send_status_keyval(KEY_PRESS_DOUBLECLICK, TOUCH_KEY2);
 179   6                              return;
 180   6                          }
 181   5                      }
 182   4      
 183   4      // 如果不是同一个按键按下或是没有值，说明是短按
 184   4      #if USE_MY_DEBUG
                              printf("k2 press\n");
              #endif
 187   4                      send_status_keyval(KEY_PRESS_SHORT, TOUCH_KEY2); // 发送带有状态的键值
 188   4                  }
 189   3                  else if (TK_CH23_VALIB == KeyOnOutput)
 190   3                  {
 191   4                      // 如果KEY3被触摸
 192   4                      for (i = 0; i < send_sp; i++)
 193   4                      {
 194   5                          delay_ms(1);
 195   5                          __tk_scan();
 196   5                          KeyOnOutput = __tk_key_flag;
 197   5      
 198   5                          if (TK_CH23_VALIB == KeyOnOutput)
 199   5                          {
 200   6                              // 如果检测到是同一个按键按下，说明是双击
 201   6                              // 等待手指松开按键，不然发送完带有双击状态的键值后会再发送一次单击状态的键值
 202   6                              while (0 != KeyOnOutput)
 203   6                              {
 204   7                                  __tk_scan();
 205   7                                  KeyOnOutput = __tk_key_flag;
 206   7                              }
 207   6      
 208   6      #if USE_MY_DEBUG
                                      printf("k3 double press\n");
              #endif
 211   6                              send_status_keyval(KEY_PRESS_DOUBLECLICK, TOUCH_KEY3);
 212   6                              return;
 213   6                          }
 214   5                      }
 215   4      
 216   4                      // 如果不是同一个按键按下或是没有值，说明是短按
 217   4      #if USE_MY_DEBUG
                              printf("k3 press\n");
              #endif
 220   4                      send_status_keyval(KEY_PRESS_SHORT, TOUCH_KEY3); // 发送带有状态的键值
 221   4                  }
 222   3                  else if (TK_CH17_VALIB == KeyOnOutput)
 223   3                  {
 224   4                      // 如果KEY4被触摸
 225   4                      for (i = 0; i < send_sp; i++)
 226   4                      {
 227   5                          delay_ms(1);
 228   5                          __tk_scan();
 229   5                          KeyOnOutput = __tk_key_flag;
 230   5      
 231   5                          if (TK_CH17_VALIB == KeyOnOutput)
 232   5                          {
 233   6                              // 如果检测到是同一个按键按下，说明是双击
 234   6                              // 等待手指松开按键，不然发送完带有双击状态的键值后会再发送一次单击状态的键值
 235   6                              while (0 != KeyOnOutput)
 236   6                              {
 237   7                                  __tk_scan();
C51 COMPILER V9.60.7.0   TK_USER                                                           11/12/2024 17:21:53 PAGE 5   

 238   7                                  KeyOnOutput = __tk_key_flag;
 239   7                              }
 240   6      
 241   6      #if USE_MY_DEBUG
                                      printf("k4 double press\n");
              #endif
 244   6                              send_status_keyval(KEY_PRESS_DOUBLECLICK, TOUCH_KEY4);
 245   6                              return;
 246   6                          }
 247   5                      }
 248   4      
 249   4                      // 如果不是同一个按键按下或是没有值，说明是短按
 250   4      #if USE_MY_DEBUG
                              printf("k4 press\n");
              #endif
 253   4                      send_status_keyval(KEY_PRESS_SHORT, TOUCH_KEY4); // 发送带有状态的键值
 254   4                  }
 255   3                  else if (TK_CH15_VALIB == KeyOnOutput)
 256   3                  {
 257   4                      // 如果KEY5被触摸
 258   4                      for (i = 0; i < send_sp; i++)
 259   4                      {
 260   5                          delay_ms(1);
 261   5                          __tk_scan();
 262   5                          KeyOnOutput = __tk_key_flag;
 263   5      
 264   5                          if (TK_CH15_VALIB == KeyOnOutput)
 265   5                          {
 266   6                              // 如果检测到是同一个按键按下，说明是双击
 267   6                              // 等待手指松开按键，不然发送完带有双击状态的键值后会再发送一次单击状态的键值
 268   6                              while (0 != KeyOnOutput)
 269   6                              {
 270   7                                  __tk_scan();
 271   7                                  KeyOnOutput = __tk_key_flag;
 272   7                              }
 273   6      #if USE_MY_DEBUG
                                      printf("k5 double press\n");
              #endif
 276   6                              send_status_keyval(KEY_PRESS_DOUBLECLICK, TOUCH_KEY5);
 277   6                              return;
 278   6                          }
 279   5                      }
 280   4      
 281   4      // 如果不是同一个按键按下或是没有值，说明是短按
 282   4      #if USE_MY_DEBUG
                              printf("k5 press\n");
              #endif
 285   4                      send_status_keyval(KEY_PRESS_SHORT, TOUCH_KEY5); // 发送带有状态的键值
 286   4                  }
 287   3              }
 288   2          }
 289   1      
 290   1          if (1 == long_touch_flag && 0 != KeyOnOutput)
 291   1          {
 292   2              KeyOld = KeyOnOutput;
 293   2      
 294   2              // 如果之前是长按，现在还未松开
 295   2              // 判断当前触摸的键值，做对应的操作
 296   2              if (TK_CH24_VALIB == KeyOnOutput)
 297   2              {
 298   3                  // 如果KEY1被触摸
 299   3                  if (cnt >= TK_LONG_KEY_TIME && cnt < 90)
C51 COMPILER V9.60.7.0   TK_USER                                                           11/12/2024 17:21:53 PAGE 6   

 300   3                  {
 301   4      #if USE_MY_DEBUG
                              printf("k1 long press\n");
              #endif
 304   4                      send_status_keyval(KEY_PRESS_LONG, TOUCH_KEY1);
 305   4                  }
 306   3      
 307   3                  // 若还不松开手，则每隔150ms发送一次带有持续状态信息的键值信号
 308   3                  while (0 != KeyOnOutput)
 309   3                  {
 310   4                      delay_ms(10);
 311   4                      cnt++;
 312   4                      __tk_scan();
 313   4                      KeyOnOutput = __tk_key_flag;
 314   4      
 315   4                      if (cnt >= 87) // 原本是填90的，但是软件延时有误差，这里只能慢慢调试
 316   4                      {
 317   5                          cnt = TK_LONG_KEY_TIME;
 318   5      #if USE_MY_DEBUG
                                  printf("k1 continue press\n");
              #endif
 321   5                          send_status_keyval(KEY_PRESS_CONTINUE, TOUCH_KEY1);
 322   5                      }
 323   4                  }
 324   3              }
 325   2              else if (TK_CH25_VALIB == KeyOnOutput)
 326   2              {
 327   3                  // 如果KEY2被触摸
 328   3                  if (cnt >= TK_LONG_KEY_TIME && cnt < 90)
 329   3                  {
 330   4      #if USE_MY_DEBUG
                              printf("k2 long press\n");
              #endif
 333   4                      send_status_keyval(KEY_PRESS_LONG, TOUCH_KEY2);
 334   4                  }
 335   3      
 336   3                  // 若还不松开手，则每隔150ms发送一次带有持续状态信息的键值信号
 337   3                  while (0 != KeyOnOutput)
 338   3                  {
 339   4                      delay_ms(10);
 340   4                      cnt++;
 341   4                      __tk_scan();
 342   4                      KeyOnOutput = __tk_key_flag;
 343   4      
 344   4                      if (cnt >= 87) // 原本是填90的，但是软件延时有误差，这里只能慢慢调试
 345   4                      {
 346   5                          cnt = TK_LONG_KEY_TIME;
 347   5      #if USE_MY_DEBUG
                                  printf("k2 continue press\n");
              #endif
 350   5                          send_status_keyval(KEY_PRESS_CONTINUE, TOUCH_KEY2);
 351   5                      }
 352   4                  }
 353   3      
 354   3                  // display_data ^= 0x0200; // 对应的LED状态取反，后面会调用led_display()刷新
 355   3                  // led_display();          // LED状态更新显示
 356   3              }
 357   2              else if (TK_CH23_VALIB == KeyOnOutput)
 358   2              {
 359   3                  // 如果KEY3被触摸
 360   3                  if (cnt >= TK_LONG_KEY_TIME && cnt < 90)
 361   3                  {
C51 COMPILER V9.60.7.0   TK_USER                                                           11/12/2024 17:21:53 PAGE 7   

 362   4      #if USE_MY_DEBUG
                              printf("k3 long press\n");
              #endif
 365   4                      send_status_keyval(KEY_PRESS_LONG, TOUCH_KEY3);
 366   4                  }
 367   3      
 368   3                  // 若还不松开手，则每隔150ms发送一次带有持续状态信息的键值信号
 369   3                  while (0 != KeyOnOutput)
 370   3                  {
 371   4                      delay_ms(10);
 372   4                      cnt++;
 373   4                      __tk_scan();
 374   4                      KeyOnOutput = __tk_key_flag;
 375   4      
 376   4                      if (cnt >= 87) // 原本是填90的，但是软件延时有误差，这里只能慢慢调试
 377   4                      {
 378   5                          cnt = TK_LONG_KEY_TIME;
 379   5      #if USE_MY_DEBUG
                                  printf("k3 continue press\n");
              #endif
 382   5                          send_status_keyval(KEY_PRESS_CONTINUE, TOUCH_KEY3);
 383   5                      }
 384   4                  }
 385   3              }
 386   2              else if (TK_CH17_VALIB == KeyOnOutput)
 387   2              {
 388   3                  // 如果KEY4被触摸
 389   3                  if (cnt >= TK_LONG_KEY_TIME && cnt < 90)
 390   3                  {
 391   4                      // display_data ^= 0x0800; // 对应的LED状态取反，后面会调用led_display()刷新
 392   4                      // led_display();          // LED状态更新显示
 393   4      #if USE_MY_DEBUG
                              printf("k4 long press\n");
              #endif
 396   4                      send_status_keyval(KEY_PRESS_LONG, TOUCH_KEY4);
 397   4                  }
 398   3      
 399   3                  // 若还不松开手，则每隔150ms发送一次带有持续状态信息的键值信号
 400   3                  while (0 != KeyOnOutput)
 401   3                  {
 402   4                      delay_ms(10);
 403   4                      cnt++;
 404   4                      __tk_scan();
 405   4                      KeyOnOutput = __tk_key_flag;
 406   4      
 407   4                      if (cnt >= 87) // 原本是填90的，但是软件延时有误差，这里只能慢慢调试
 408   4                      {
 409   5                          cnt = TK_LONG_KEY_TIME;
 410   5      #if USE_MY_DEBUG
                                  printf("k4 continue press\n");
              #endif
 413   5                          send_status_keyval(KEY_PRESS_CONTINUE, TOUCH_KEY4);
 414   5                      }
 415   4                  }
 416   3      
 417   3                  // display_data ^= 0x0800; // 对应的LED状态取反，后面会调用led_display()刷新
 418   3                  // led_display();          // LED状态更新显示
 419   3              }
 420   2              else if (TK_CH15_VALIB == KeyOnOutput)
 421   2              {
 422   3                  // 如果KEY5被触摸
 423   3                  if (cnt >= TK_LONG_KEY_TIME && cnt < 90)
C51 COMPILER V9.60.7.0   TK_USER                                                           11/12/2024 17:21:53 PAGE 8   

 424   3                  {
 425   4                      // display_data ^= 0x0800; // 对应的LED状态取反，后面会调用led_display()刷新
 426   4                      // led_display();          // LED状态更新显示
 427   4      #if USE_MY_DEBUG
                              printf("k5 long press\n");
              #endif
 430   4                      send_status_keyval(KEY_PRESS_LONG, TOUCH_KEY5);
 431   4                  }
 432   3      
 433   3                  // 若还不松开手，则每隔150ms发送一次带有持续状态信息的键值信号
 434   3                  while (0 != KeyOnOutput)
 435   3                  {
 436   4                      delay_ms(10);
 437   4                      cnt++;
 438   4                      __tk_scan();
 439   4                      KeyOnOutput = __tk_key_flag;
 440   4      
 441   4                      if (cnt >= 87) // 原本是填90的，但是软件延时有误差，这里只能慢慢调试
 442   4                      {
 443   5                          cnt = TK_LONG_KEY_TIME;
 444   5      #if USE_MY_DEBUG
                                  printf("k5 continue press\n");
              #endif
 447   5                          send_status_keyval(KEY_PRESS_CONTINUE, TOUCH_KEY5);
 448   5                      }
 449   4                  }
 450   3      
 451   3                  // display_data ^= 0x0800; // 对应的LED状态取反，后面会调用led_display()刷新
 452   3                  // led_display();          // LED状态更新显示
 453   3              }
 454   2          }
 455   1          else if (1 == long_touch_flag && 0 == KeyOnOutput)
 456   1          {
 457   2              // 如果之前是长按，现在却松开了按键
 458   2              switch (KeyOld)
 459   2              {
 460   3              case TK_CH24_VALIB:
 461   3      #if USE_MY_DEBUG
                          printf("k1 long press loose\n");
              #endif
 464   3                  send_status_keyval(KEY_PRESS_LOOSE, TOUCH_KEY1);
 465   3                  break;
 466   3      
 467   3              case TK_CH25_VALIB:
 468   3      #if USE_MY_DEBUG
                          printf("k2 long press loose\n");
              #endif
 471   3                  send_status_keyval(KEY_PRESS_LOOSE, TOUCH_KEY2);
 472   3                  break;
 473   3      
 474   3              case TK_CH23_VALIB:
 475   3      #if USE_MY_DEBUG
                          printf("k3 long press loose\n");
              #endif
 478   3                  send_status_keyval(KEY_PRESS_LOOSE, TOUCH_KEY3);
 479   3                  break;
 480   3      
 481   3              case TK_CH17_VALIB:
 482   3      #if USE_MY_DEBUG
                          printf("k4 long press loose\n");
              #endif
 485   3                  send_status_keyval(KEY_PRESS_LOOSE, TOUCH_KEY4);
C51 COMPILER V9.60.7.0   TK_USER                                                           11/12/2024 17:21:53 PAGE 9   

 486   3                  break;
 487   3      
 488   3              case TK_CH15_VALIB:
 489   3      #if USE_MY_DEBUG
                          printf("k5 long press loose\n");
              #endif
 492   3                  send_status_keyval(KEY_PRESS_LOOSE, TOUCH_KEY5);
 493   3                  break;
 494   3              }
 495   2      
 496   2              long_touch_flag = 0; // 清除标志位
 497   2              cnt = 0;
 498   2              KeyOld = 0;
 499   2          }
 500   1      
 501   1      #if 0
                  if (1 == __tk_long_key_flag) // 如果长按按键（这个功能测试发现不行，不能用）
                  {
                      __tk_long_key_flag = 0;
              
                      // 这里可以自己处理，添加自己需要的功能
              
                      P11 = 0;
                  }
              #endif
 511   1      }
 512          
 513          /*************************** (C) COPYRIGHT 2022 TAIXIN-IC ***** END OF FILE *****/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2653    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     11      10
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
