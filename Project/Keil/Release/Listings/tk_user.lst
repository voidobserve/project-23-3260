C51 COMPILER V9.60.7.0   TK_USER                                                           11/11/2024 17:28:53 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE TK_USER
OBJECT MODULE PLACED IN .\Release\Objects\tk_user.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\tk_user.c LARGE OPTIMIZE(8,SPEED) BROWSE INTVECTOR(0X000C) IN
                    -CDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Li
                    -stings\tk_user.lst) OBJECT(.\Release\Objects\tk_user.obj)

line level    source

   1          /**
   2           ******************************************************************************
   3           * @file    User/tk_user.c
   4           * @author  HUGE-IC Application Team
   5           * @version V1.0.0
   6           * @date    05-20-2022
   7           * @brief   Main program body
   8           ******************************************************************************
   9           * @attention
  10           *
  11           * <h2><center>&copy; COPYRIGHT 2022 TAIXIN-IC</center></h2>
  12           *
  13           *
  14           *
  15           ******************************************************************************
  16           */
  17          
  18          /* Includes ------------------------------------------------------------------*/
  19          #include <stdio.h>
  20          #include "include.h"
  21          #include "my_config.h"
  22          
  23          /** @addtogroup Template_Project
  24           * @{
  25           */
  26          
  27          /* Private typedef -----------------------------------------------------------*/
  28          /* Private define ------------------------------------------------------------*/
  29          /* Private macro -------------------------------------------------------------*/
  30          /* Private variables ---------------------------------------------------------*/
  31          /* Private function prototypes -----------------------------------------------*/
  32          /* Private functions ---------------------------------------------------------*/
  33          
  34          /**
  35           * @brief  Touchkey  debug uart init function
  36           * @param  None
  37           * @retval None
  38           */
  39          // xdata u16 led_data[1];                           // LED显示buff
  40          #define LED_DIS_FREQ (1000000 / 16 / 8 / 60 - 1) // 一个CON的显示时间60Hz    60-1=1M/(LED_COMCON*16*LED_TI
             -ME_CON)
  41          
  42          unsigned int xdata display_data = 0;
  43          
  44          /**
  45           * @brief  调试接口IO初始化函数.
  46           * @param  None
  47           * @retval None
  48           */
  49          #if TK_DEBUG_EN
              void debug_gpio_config(void)
              {
              #if 1
C51 COMPILER V9.60.7.0   TK_USER                                                           11/11/2024 17:28:53 PAGE 2   

                  P2_MD0 &= ~GPIO_P21_MODE_SEL(0x03);
                  P2_MD0 |= GPIO_P21_MODE_SEL(0x01);
                  FOUT_S21 = GPIO_FOUT_UART1_TX;
              #else
                  P2_MD1 &= ~GPIO_P27_MODE_SEL(0x03);
                  P2_MD1 |= GPIO_P27_MODE_SEL(0x01);
                  FOUT_S27 = GPIO_FOUT_UART1_TX;
              #endif
              }
              #endif
  63          
  64          /**
  65           * @brief  用户代码循环执行函数接口.（触摸按键扫描函数接口）
  66           * @param  None
  67           * @retval None
  68           */
  69          #define send_sp (100)
  70          void user_handle(void)
  71          {
  72   1          volatile unsigned long int KeyOnOutput = __tk_key_flag; // __tk_key_flag单次按键标志
  73   1      
  74   1          static volatile unsigned long int KeyOld = 0; // 用于存放长按时，对应的按键
  75   1      
  76   1          // 是否长按的标志，0--否，1--是
  77   1          // 需要保存长按的状态，表示定时器一直在发送键值
  78   1          static unsigned char long_touch_flag = 0; // 上一次扫描到的按键是否为长按的标志
  79   1      
  80   1          static volatile u32 cnt = 0; // 长按计数值
  81   1      
  82   1          u32 i = 0; // 循环计数值
  83   1      
  84   1          u16 send_data = 0; // 要发送的带有键值的数据
  85   1      
  86   1          if (KeyOnOutput && 0 == long_touch_flag && cnt < TK_LONG_KEY_TIME) // 如果有按键按下（并且之前扫描到的
             -不是长按）
  87   1          {
  88   2              // 通过循环判断是否为长按
  89   2              for (i = 0; i < 500000; i++) // 实际上用不到这么大的数字，到了设定的长按时间就会退出
  90   2              {
  91   3                  // 按键扫描函数，使用了库里面的接口（闭源库）
  92   3                  // 这个函数会更新__tk_key_flag的值
  93   3                  delay_ms(10);
  94   3                  __tk_scan();
  95   3      
  96   3                  if (KeyOnOutput == __tk_key_flag)
  97   3                  {
  98   4                      // 如果按键键值一致，说明按键一直被按下，未松开
  99   4                      cnt++;
 100   4                  }
 101   3                  else
 102   3                  {
 103   4                      // 如果按键键值不一致或是松开了按键
 104   4                      // cnt = 0;
 105   4                      break;
 106   4                  }
 107   3                  if (cnt > TK_LONG_KEY_TIME) // 如果长按超过了这里设置的时间
 108   3                  {
 109   4                      long_touch_flag = 1; // 标记为长按
 110   4                      break;
 111   4                  }
 112   3              }
 113   2      
C51 COMPILER V9.60.7.0   TK_USER                                                           11/11/2024 17:28:53 PAGE 3   

 114   2              if (cnt > TK_LONG_KEY_TIME)
 115   2              {
 116   3                  long_touch_flag = 1; // 标记为长按
 117   3              }
 118   2              else
 119   2              {
 120   3                  // 如果是短按
 121   3                  cnt = 0; // 清除长按的计数值
 122   3      
 123   3                  // 判断当前触摸的键值，做对应的操作
 124   3                  if (TK_CH24_VALIB == KeyOnOutput)
 125   3                  {
 126   4                      // 如果KEY1被触摸
 127   4                      for (i = 0; i < send_sp; i++)
 128   4                      {
 129   5                          delay_ms(1);
 130   5                          __tk_scan();
 131   5                          KeyOnOutput = __tk_key_flag;
 132   5      
 133   5                          if (TK_CH24_VALIB == KeyOnOutput)
 134   5                          {
 135   6                              // 如果检测到是同一个按键按下，说明是双击
 136   6                              // 等待手指松开按键，不然发送完带有双击状态的键值后会再发送一次单击状态的键值
 137   6                              while (0 != KeyOnOutput)
 138   6                              {
 139   7                                  __tk_scan();
 140   7                                  KeyOnOutput = __tk_key_flag;
 141   7                              }
 142   6      #if USE_MY_DEBUG
 143   6                              printf("k1 double press\n");
 144   6      #endif
 145   6                              send_status_keyval(KEY_PRESS_DOUBLECLICK, TOUCH_KEY1);
 146   6                              return;
 147   6                          }
 148   5                      }
 149   4      
 150   4      // 如果不是同一个按键按下或是没有值，说明是短按
 151   4      #if USE_MY_DEBUG
 152   4                      printf("k1 press\n");
 153   4      #endif
 154   4                      send_status_keyval(KEY_PRESS_SHORT, TOUCH_KEY1); // 发送带有状态的键值
 155   4                  }
 156   3                  else if (TK_CH25_VALIB == KeyOnOutput)
 157   3                  {
 158   4                      // 如果KEY2被触摸
 159   4                      for (i = 0; i < send_sp; i++)
 160   4                      {
 161   5                          delay_ms(1);
 162   5                          __tk_scan();
 163   5                          KeyOnOutput = __tk_key_flag;
 164   5      
 165   5                          if (TK_CH25_VALIB == KeyOnOutput)
 166   5                          {
 167   6                              // 如果检测到是同一个按键按下，说明是双击
 168   6                              // 等待手指松开按键，不然发送完带有双击状态的键值后会再发送一次单击状态的键值
 169   6                              while (0 != KeyOnOutput)
 170   6                              {
 171   7                                  __tk_scan();
 172   7                                  KeyOnOutput = __tk_key_flag;
 173   7                              }
 174   6      #if USE_MY_DEBUG
 175   6                              printf("k2 double press\n");
C51 COMPILER V9.60.7.0   TK_USER                                                           11/11/2024 17:28:53 PAGE 4   

 176   6      #endif
 177   6                              send_status_keyval(KEY_PRESS_DOUBLECLICK, TOUCH_KEY2);
 178   6                              return;
 179   6                          }
 180   5                      }
 181   4      
 182   4      // 如果不是同一个按键按下或是没有值，说明是短按
 183   4      #if USE_MY_DEBUG
 184   4                      printf("k2 press\n");
 185   4      #endif
 186   4                      send_status_keyval(KEY_PRESS_SHORT, TOUCH_KEY2); // 发送带有状态的键值
 187   4                  }
 188   3                  else if (TK_CH23_VALIB == KeyOnOutput)
 189   3                  {
 190   4                      // 如果KEY3被触摸
 191   4                      for (i = 0; i < send_sp; i++)
 192   4                      {
 193   5                          delay_ms(1);
 194   5                          __tk_scan();
 195   5                          KeyOnOutput = __tk_key_flag;
 196   5      
 197   5                          if (TK_CH23_VALIB == KeyOnOutput)
 198   5                          {
 199   6                              // 如果检测到是同一个按键按下，说明是双击
 200   6                              // 等待手指松开按键，不然发送完带有双击状态的键值后会再发送一次单击状态的键值
 201   6                              while (0 != KeyOnOutput)
 202   6                              {
 203   7                                  __tk_scan();
 204   7                                  KeyOnOutput = __tk_key_flag;
 205   7                              }
 206   6      
 207   6      #if USE_MY_DEBUG
 208   6                              printf("k3 double press\n");
 209   6      #endif
 210   6                              send_status_keyval(KEY_PRESS_DOUBLECLICK, TOUCH_KEY3);
 211   6                              return;
 212   6                          }
 213   5                      }
 214   4      
 215   4                      // 如果不是同一个按键按下或是没有值，说明是短按
 216   4      #if USE_MY_DEBUG
 217   4                      printf("k3 press\n");
 218   4      #endif
 219   4                      send_status_keyval(KEY_PRESS_SHORT, TOUCH_KEY3); // 发送带有状态的键值
 220   4                  }
 221   3                  else if (TK_CH17_VALIB == KeyOnOutput)
 222   3                  {
 223   4                      // 如果KEY4被触摸
 224   4                      for (i = 0; i < send_sp; i++)
 225   4                      {
 226   5                          delay_ms(1);
 227   5                          __tk_scan();
 228   5                          KeyOnOutput = __tk_key_flag;
 229   5      
 230   5                          if (TK_CH17_VALIB == KeyOnOutput)
 231   5                          {
 232   6                              // 如果检测到是同一个按键按下，说明是双击
 233   6                              // 等待手指松开按键，不然发送完带有双击状态的键值后会再发送一次单击状态的键值
 234   6                              while (0 != KeyOnOutput)
 235   6                              {
 236   7                                  __tk_scan();
 237   7                                  KeyOnOutput = __tk_key_flag;
C51 COMPILER V9.60.7.0   TK_USER                                                           11/11/2024 17:28:53 PAGE 5   

 238   7                              }
 239   6      
 240   6      #if USE_MY_DEBUG
 241   6                              printf("k4 double press\n");
 242   6      #endif
 243   6                              send_status_keyval(KEY_PRESS_DOUBLECLICK, TOUCH_KEY4);
 244   6                              return;
 245   6                          }
 246   5                      }
 247   4      
 248   4                      // 如果不是同一个按键按下或是没有值，说明是短按
 249   4      #if USE_MY_DEBUG
 250   4                      printf("k4 press\n");
 251   4      #endif
 252   4                      send_status_keyval(KEY_PRESS_SHORT, TOUCH_KEY4); // 发送带有状态的键值
 253   4                  }
 254   3                  else if (TK_CH15_VALIB == KeyOnOutput)
 255   3                  {
 256   4                      // 如果KEY5被触摸
 257   4                      for (i = 0; i < send_sp; i++)
 258   4                      {
 259   5                          delay_ms(1);
 260   5                          __tk_scan();
 261   5                          KeyOnOutput = __tk_key_flag;
 262   5      
 263   5                          if (TK_CH15_VALIB == KeyOnOutput)
 264   5                          {
 265   6                              // 如果检测到是同一个按键按下，说明是双击
 266   6                              // 等待手指松开按键，不然发送完带有双击状态的键值后会再发送一次单击状态的键值
 267   6                              while (0 != KeyOnOutput)
 268   6                              {
 269   7                                  __tk_scan();
 270   7                                  KeyOnOutput = __tk_key_flag;
 271   7                              }
 272   6      #if USE_MY_DEBUG
 273   6                              printf("k5 double press\n");
 274   6      #endif
 275   6                              send_status_keyval(KEY_PRESS_DOUBLECLICK, TOUCH_KEY5);
 276   6                              return;
 277   6                          }
 278   5                      }
 279   4      
 280   4      // 如果不是同一个按键按下或是没有值，说明是短按
 281   4      #if USE_MY_DEBUG
 282   4                      printf("k5 press\n");
 283   4      #endif
 284   4                      send_status_keyval(KEY_PRESS_SHORT, TOUCH_KEY5); // 发送带有状态的键值
 285   4                  }
 286   3              }
 287   2          }
 288   1      
 289   1          if (1 == long_touch_flag && 0 != KeyOnOutput)
 290   1          {
 291   2              KeyOld = KeyOnOutput;
 292   2      
 293   2              // 如果之前是长按，现在还未松开
 294   2              // 判断当前触摸的键值，做对应的操作
 295   2              if (TK_CH24_VALIB == KeyOnOutput)
 296   2              {
 297   3                  // 如果KEY1被触摸
 298   3                  if (cnt >= TK_LONG_KEY_TIME && cnt < 90)
 299   3                  {
C51 COMPILER V9.60.7.0   TK_USER                                                           11/11/2024 17:28:53 PAGE 6   

 300   4      #if USE_MY_DEBUG
 301   4                      printf("k1 long press\n");
 302   4      #endif
 303   4                      send_status_keyval(KEY_PRESS_LONG, TOUCH_KEY1);
 304   4                  }
 305   3      
 306   3                  // 若还不松开手，则每隔150ms发送一次带有持续状态信息的键值信号
 307   3                  while (0 != KeyOnOutput)
 308   3                  {
 309   4                      delay_ms(10);
 310   4                      cnt++;
 311   4                      __tk_scan();
 312   4                      KeyOnOutput = __tk_key_flag;
 313   4      
 314   4                      if (cnt >= 87) // 原本是填90的，但是软件延时有误差，这里只能慢慢调试
 315   4                      {
 316   5                          cnt = TK_LONG_KEY_TIME;
 317   5      #if USE_MY_DEBUG
 318   5                          printf("k1 continue press\n");
 319   5      #endif
 320   5                          send_status_keyval(KEY_PRESS_CONTINUE, TOUCH_KEY1);
 321   5                      }
 322   4                  }
 323   3              }
 324   2              else if (TK_CH25_VALIB == KeyOnOutput)
 325   2              {
 326   3                  // 如果KEY2被触摸
 327   3                  if (cnt >= TK_LONG_KEY_TIME && cnt < 90)
 328   3                  {
 329   4      #if USE_MY_DEBUG
 330   4                      printf("k2 long press\n");
 331   4      #endif
 332   4                      send_status_keyval(KEY_PRESS_LONG, TOUCH_KEY2);
 333   4                  }
 334   3      
 335   3                  // 若还不松开手，则每隔150ms发送一次带有持续状态信息的键值信号
 336   3                  while (0 != KeyOnOutput)
 337   3                  {
 338   4                      delay_ms(10);
 339   4                      cnt++;
 340   4                      __tk_scan();
 341   4                      KeyOnOutput = __tk_key_flag;
 342   4      
 343   4                      if (cnt >= 87) // 原本是填90的，但是软件延时有误差，这里只能慢慢调试
 344   4                      {
 345   5                          cnt = TK_LONG_KEY_TIME;
 346   5      #if USE_MY_DEBUG
 347   5                          printf("k2 continue press\n");
 348   5      #endif
 349   5                          send_status_keyval(KEY_PRESS_CONTINUE, TOUCH_KEY2);
 350   5                      }
 351   4                  }
 352   3      
 353   3                  // display_data ^= 0x0200; // 对应的LED状态取反，后面会调用led_display()刷新
 354   3                  // led_display();          // LED状态更新显示
 355   3              }
 356   2              else if (TK_CH23_VALIB == KeyOnOutput)
 357   2              {
 358   3                  // 如果KEY3被触摸
 359   3                  if (cnt >= TK_LONG_KEY_TIME && cnt < 90)
 360   3                  {
 361   4      #if USE_MY_DEBUG
C51 COMPILER V9.60.7.0   TK_USER                                                           11/11/2024 17:28:53 PAGE 7   

 362   4                      printf("k3 long press\n");
 363   4      #endif
 364   4                      send_status_keyval(KEY_PRESS_LONG, TOUCH_KEY3);
 365   4                  }
 366   3      
 367   3                  // 若还不松开手，则每隔150ms发送一次带有持续状态信息的键值信号
 368   3                  while (0 != KeyOnOutput)
 369   3                  {
 370   4                      delay_ms(10);
 371   4                      cnt++;
 372   4                      __tk_scan();
 373   4                      KeyOnOutput = __tk_key_flag;
 374   4      
 375   4                      if (cnt >= 87) // 原本是填90的，但是软件延时有误差，这里只能慢慢调试
 376   4                      {
 377   5                          cnt = TK_LONG_KEY_TIME;
 378   5      #if USE_MY_DEBUG
 379   5                          printf("k3 continue press\n");
 380   5      #endif
 381   5                          send_status_keyval(KEY_PRESS_CONTINUE, TOUCH_KEY3);
 382   5                      }
 383   4                  }
 384   3              }
 385   2              else if (TK_CH17_VALIB == KeyOnOutput)
 386   2              {
 387   3                  // 如果KEY4被触摸
 388   3                  if (cnt >= TK_LONG_KEY_TIME && cnt < 90)
 389   3                  {
 390   4                      // display_data ^= 0x0800; // 对应的LED状态取反，后面会调用led_display()刷新
 391   4                      // led_display();          // LED状态更新显示
 392   4      #if USE_MY_DEBUG
 393   4                      printf("k4 long press\n");
 394   4      #endif
 395   4                      send_status_keyval(KEY_PRESS_LONG, TOUCH_KEY4);
 396   4                  }
 397   3      
 398   3                  // 若还不松开手，则每隔150ms发送一次带有持续状态信息的键值信号
 399   3                  while (0 != KeyOnOutput)
 400   3                  {
 401   4                      delay_ms(10);
 402   4                      cnt++;
 403   4                      __tk_scan();
 404   4                      KeyOnOutput = __tk_key_flag;
 405   4      
 406   4                      if (cnt >= 87) // 原本是填90的，但是软件延时有误差，这里只能慢慢调试
 407   4                      {
 408   5                          cnt = TK_LONG_KEY_TIME;
 409   5      #if USE_MY_DEBUG
 410   5                          printf("k4 continue press\n");
 411   5      #endif
 412   5                          send_status_keyval(KEY_PRESS_CONTINUE, TOUCH_KEY4);
 413   5                      }
 414   4                  }
 415   3      
 416   3                  // display_data ^= 0x0800; // 对应的LED状态取反，后面会调用led_display()刷新
 417   3                  // led_display();          // LED状态更新显示
 418   3              }
 419   2              else if (TK_CH15_VALIB == KeyOnOutput)
 420   2              {
 421   3                  // 如果KEY5被触摸
 422   3                  if (cnt >= TK_LONG_KEY_TIME && cnt < 90)
 423   3                  {
C51 COMPILER V9.60.7.0   TK_USER                                                           11/11/2024 17:28:53 PAGE 8   

 424   4                      // display_data ^= 0x0800; // 对应的LED状态取反，后面会调用led_display()刷新
 425   4                      // led_display();          // LED状态更新显示
 426   4      #if USE_MY_DEBUG
 427   4                      printf("k5 long press\n");
 428   4      #endif
 429   4                      send_status_keyval(KEY_PRESS_LONG, TOUCH_KEY5);
 430   4                  }
 431   3      
 432   3                  // 若还不松开手，则每隔150ms发送一次带有持续状态信息的键值信号
 433   3                  while (0 != KeyOnOutput)
 434   3                  {
 435   4                      delay_ms(10);
 436   4                      cnt++;
 437   4                      __tk_scan();
 438   4                      KeyOnOutput = __tk_key_flag;
 439   4      
 440   4                      if (cnt >= 87) // 原本是填90的，但是软件延时有误差，这里只能慢慢调试
 441   4                      {
 442   5                          cnt = TK_LONG_KEY_TIME;
 443   5      #if USE_MY_DEBUG
 444   5                          printf("k5 continue press\n");
 445   5      #endif
 446   5                          send_status_keyval(KEY_PRESS_CONTINUE, TOUCH_KEY5);
 447   5                      }
 448   4                  }
 449   3      
 450   3                  // display_data ^= 0x0800; // 对应的LED状态取反，后面会调用led_display()刷新
 451   3                  // led_display();          // LED状态更新显示
 452   3              }
 453   2          }
 454   1          else if (1 == long_touch_flag && 0 == KeyOnOutput)
 455   1          {
 456   2              // 如果之前是长按，现在却松开了按键
 457   2              switch (KeyOld)
 458   2              {
 459   3              case TK_CH24_VALIB:
 460   3      #if USE_MY_DEBUG
 461   3                  printf("k1 long press loose\n");
 462   3      #endif
 463   3                  send_status_keyval(KEY_PRESS_LOOSE, TOUCH_KEY1);
 464   3                  break;
 465   3      
 466   3              case TK_CH25_VALIB:
 467   3      #if USE_MY_DEBUG
 468   3                  printf("k2 long press loose\n");
 469   3      #endif
 470   3                  send_status_keyval(KEY_PRESS_LOOSE, TOUCH_KEY2);
 471   3                  break;
 472   3      
 473   3              case TK_CH23_VALIB:
 474   3      #if USE_MY_DEBUG
 475   3                  printf("k3 long press loose\n");
 476   3      #endif
 477   3                  send_status_keyval(KEY_PRESS_LOOSE, TOUCH_KEY3);
 478   3                  break;
 479   3      
 480   3              case TK_CH17_VALIB:
 481   3      #if USE_MY_DEBUG
 482   3                  printf("k4 long press loose\n");
 483   3      #endif
 484   3                  send_status_keyval(KEY_PRESS_LOOSE, TOUCH_KEY4);
 485   3                  break;
C51 COMPILER V9.60.7.0   TK_USER                                                           11/11/2024 17:28:53 PAGE 9   

 486   3      
 487   3              case TK_CH15_VALIB:
 488   3      #if USE_MY_DEBUG
 489   3                  printf("k5 long press loose\n");
 490   3      #endif
 491   3                  send_status_keyval(KEY_PRESS_LOOSE, TOUCH_KEY5);
 492   3                  break;
 493   3              }
 494   2      
 495   2              long_touch_flag = 0; // 清除标志位
 496   2              cnt = 0;
 497   2              KeyOld = 0;
 498   2          }
 499   1      
 500   1      #if 0
                  if (1 == __tk_long_key_flag) // 如果长按按键（这个功能测试发现不行，不能用）
                  {
                      __tk_long_key_flag = 0;
              
                      // 这里可以自己处理，添加自己需要的功能
              
                      P11 = 0;
                  }
              #endif
 510   1      }
 511          
 512          /*************************** (C) COPYRIGHT 2022 TAIXIN-IC ***** END OF FILE *****/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2884    ----
   CONSTANT SIZE    =    410    ----
   XDATA SIZE       =     11      10
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
