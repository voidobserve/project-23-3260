C51 COMPILER V9.60.7.0   AIP650                                                            12/02/2024 16:50:47 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE AIP650
OBJECT MODULE PLACED IN .\Release\Objects\aip650.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\Hardware\aip650.c LARGE OPTIMIZE(8,SPEED) BROWSE INTVECTOR(0X000C)
                    - INCDIR(..\..\Libraries\Include;..\..\Hardware;..\..\User;..\..\User\lib) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release
                    -\Listings\aip650.lst) OBJECT(.\Release\Objects\aip650.obj)

line level    source

   1          #include "aip650.h"
   2          #include <string.h>
   3          
   4          // 0 1 2 3 4 5 6 7 8 9 NULL -
   5          // u8 leddata[] = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F, 0x00, 0x40};
   6          
   7          /*
   8              //[0]-- com1ÊòæÁ§∫--ËøûÊé•Âà∞Á¨¨‰∫å‰∏™Êï∞Á†ÅÁÆ°(‰ªéÂ∑¶ÂæÄÂè≥Êï∞)
   9              //[1]-- com2ÊòæÁ§∫--ËøûÊé•Âà∞ÊåâÈîÆÂØπÂ∫îÁöÑLED
  10              //[2]-- com3ÊòæÁ§∫--ËøûÊé•Âà∞Á¨¨‰∏Ä‰∏™Êï∞Á†ÅÁÆ°(‰ªéÂ∑¶ÂæÄÂè≥Êï∞)
  11          */
  12          u8 aip650_show_buff[3] = {0}; // aip650ÊòæÁ§∫ÁºìÂÜ≤Âå∫ÔºàÊòæÂ≠òÔºâ
  13          
  14          volatile bit flag_is_instruction_err = 0; // Ê†áÂøó‰ΩçÔºåË°®Á§∫Êåá‰ª§ÊòØÂê¶‰∏çÁ¨¶ÂêàÊ†ºÂºè
  15          
  16          // Â≠òÊîæË¶ÅÊòæÁ§∫ÁöÑÂÜÖÂÆπ
  17          const u8 aip650_data_map_buf[] = {
  18              0xE7, // 0
  19              0x81, // 1
  20              0x75, // 2
  21              0xB5, // 3
  22              0x93, // 4
  23              0xB6, // 5
  24              0xF6, // 6
  25              0x85, // 7
  26              0xF7, // 8
  27              0xB7, // 9
  28          
  29              0x66, // Â§ßÂÜô "C"
  30              0xF1, // Â∞èÂÜô "d"
  31              0x56, // Â§ßÂÜô "F"
  32              0xD3, // Â§ßÂÜô "H"
  33              0x62, // Â§ßÂÜô "L"
  34              0xC7, // Â∞èÂÜô "n"
  35              0x57, // Â§ßÂÜô "P"
  36              0xE3, // Â§ßÂÜô "U"
  37          };
  38          
  39          /*Êåá‰ª§ÈõÜ*/
  40          
  41          // 4801--Á≥ªÁªü‰ΩøËÉΩÔºå8ÊÆµÊòæÁ§∫Ôºå8Á∫ß‰∫ÆÂ∫¶
  42          #define SYS_CMD 0x4801
  43          
  44          void aip650_config(void)
  45          {
  46   1          // 14ËÑö-P16-IIC_DATA
  47   1          // 15ËÑö-P15-IIC_CLK
  48   1          P1_MD1 &= ~((GPIO_P15_MODE_SEL(0x03)) | (GPIO_P16_MODE_SEL(0x03))); //
  49   1          P1_MD1 |= ((GPIO_P15_MODE_SEL(0x02)) | (GPIO_P16_MODE_SEL(0x02)));  // ÈÖçÁΩÆ‰∏∫Êï∞Â≠óÂ§çÁî®Ê®°Âºè
  50   1          P1_PU |= (GPIO_P15_PULL_UP(0x01) | GPIO_P16_PULL_UP(0x01));         // ‰∏äÊãâ
  51   1          P1_ODN |= (GPIO_P15_ODN_EN(0x01) | GPIO_P16_ODN_EN(0x01));          // ÂºÄÊºè
  52   1          P1_AF0 |= (GPIO_P15_FUNC_SEL(0x01) | GPIO_P16_FUNC_SEL(0x01));      // P15‰Ωú‰∏∫IIC_CLK, P16‰Ωú‰∏∫IIC_
             -DATA
C51 COMPILER V9.60.7.0   AIP650                                                            12/02/2024 16:50:47 PAGE 2   

  53   1      
  54   1          I2C_CON = I2C_CR_SEL(0x02); // ÈÖçÁΩÆÊ≥¢ÁâπÁéáÔºåÂèØÊ†πÊçÆË°®Ê†ºËá™Ë°åÈÄâÊã©
  55   1          I2C_CON |= I2C_EN(0x1);     // ‰ΩøËÉΩÊ®°Âùó
  56   1      
  57   1          // memset(sg_650e_drv._buf, 0x00, AIP650E_SIZE);
  58   1          // aip650e_update(&sg_650e_drv); // ‰∏äÁîµÁ¨¨‰∏ÄÊ¨°Ê∏ÖÁ©∫ÊòæÁ§∫
  59   1      }
  60          
  61          /**
  62           * @brief  IIC sends 1 byte data function
  63           * @param  iic_data: IIC data
  64           * @param  flag: 0: None  1:send start   2:send stop
  65           * @retval Returns 1 and receives an ACK
  66           */
  67          static u8 iic_master_tx(u8 iic_data, u8 flag)
  68          {
  69   1      #define START_FLAG (1)
  70   1      #define STOP_FLAG (2)
  71   1      
  72   1          u8 ack_flag = 0;
  73   1      
  74   1          if (flag == START_FLAG)
  75   1          {
  76   2              // ÈÖçÁΩÆÂèëÈÄÅËµ∑Âßã‰Ωç
  77   2              I2C_CON |= (I2C_START_BIT(0x1) | I2C_SI_CLEAR(0x1));
  78   2              // Á≠âÂæÖ SI ÁΩÆ 1Ôºå Ëµ∑Âßã‰ΩçÂèëÈÄÅÊàêÂäüÊó∂‰ºöÁΩÆ 1Ôºå ÂÖ∂ÂÆÉÊÉÖÂÜµ‰πüÂèØËÉΩ‰ºöÁΩÆ 1Ôºå ÈúÄË¶ÅÊ
             -≥®ÊÑè
  79   2              while (!(I2C_STA & I2C_SI_STA(0x1)))
  80   2                  ;
  81   2              I2C_CON &= ~I2C_START_BIT(0x1);
  82   2      
  83   2              // Âà§Êñ≠Ê®°ÂùóÁä∂ÊÄÅ
  84   2              if (!(((I2C_STA & I2C_STA_FLAG(0x1F)) == 0x08) ||
  85   2                    ((I2C_STA & I2C_STA_FLAG(0x1F)) == 0x10)))
  86   2              {
  87   3                  return 0;
  88   3              }
  89   2          }
  90   1      
  91   1          // ÂÜôÂÖ•ÁõÆÊ†á‰ªéÊú∫Âú∞ÂùÄ
  92   1          I2C_DATA = iic_data;
  93   1          // Á≠âÂæÖÂú∞ÂùÄÂèëÈÄÅÂÆåÊàê
  94   1          while (!(I2C_STA & I2C_SI_STA(0x1)))
  95   1              ;
  96   1      
  97   1          // Âà§Êñ≠ÊòØÂê¶Êî∂Âà∞ ACK
  98   1          if (((I2C_STA & I2C_STA_FLAG(0x1F)) == 0x18) ||
  99   1              ((I2C_STA & I2C_STA_FLAG(0x1F)) == 0x28) ||
 100   1              ((I2C_STA & I2C_STA_FLAG(0x1F)) == 0x40))
 101   1          {
 102   2              ack_flag = 1;
 103   2          }
 104   1          else
 105   1          {
 106   2              ack_flag = 0;
 107   2          }
 108   1      
 109   1          if (flag == STOP_FLAG)
 110   1          {
 111   2              // ÈÖçÁΩÆÂèëÈÄÅÂÅúÊ≠¢‰Ωç
 112   2              I2C_CON |= (I2C_STOP_BIT(0x1) | I2C_SI_CLEAR(0x1));
 113   2          }
C51 COMPILER V9.60.7.0   AIP650                                                            12/02/2024 16:50:47 PAGE 3   

 114   1      
 115   1          return ack_flag;
 116   1      }
 117          
 118          static void aip650_write_cmd(u16 cmd) //
 119          {
 120   1          iic_master_tx(cmd >> 8, 1);
 121   1          iic_master_tx(cmd & 0xFF, 2);
 122   1      }
 123          
 124          // // Êõ¥Êñ∞aip650ÁöÑÊòæÂ≠ò
 125          // void aip650_show_buff_update(u8 *buff)
 126          // {
 127          //     aip650_show_buff[0] = (aip650_show_buff[0] & ~0xFF) | buff[0];
 128          //     aip650_show_buff[1] = (aip650_show_buff[1] & ~0xFF) | buff[1];
 129          //     aip650_show_buff[2] = (aip650_show_buff[2] & ~0xFF) | buff[2];
 130          // }
 131          
 132          // Âà∑Êñ∞aip650Ë¶ÅÊòæÁ§∫ÁöÑÂÜÖÂÆπ(Â∞Üaip650ÊòæÂ≠òÁöÑÂÜÖÂÆπÊõ¥Êñ∞Âà∞Â§ñËÆæ‰∏ä)
 133          void aip650_show_refresh(void)
 134          {
 135   1          aip650_write_cmd(SYS_CMD); // ÂºÄÊòæÁ§∫Ôºå8Á∫ßÊòæÁ§∫(0x4801);Áù°Áú†‰ΩøËÉΩ„ÄÇÊó∂ÈíüÂÅúÊåØ(0x4804)
 136   1      
 137   1          // aip650_write_cmd(0x6800 | aip650_show_buff[0]); // com0ÊòæÁ§∫--Êú™ËøûÊé•‰ªª‰ΩïÁ°¨‰ª∂
 138   1          aip650_write_cmd(0x6A00 | aip650_show_buff[0]); // com1ÊòæÁ§∫--ËøûÊé•Âà∞Á¨¨‰∫å‰∏™Êï∞Á†ÅÁÆ°(‰ªéÂ∑¶ÂæÄÂè
             -≥Êï∞)
 139   1          aip650_write_cmd(0x6C00 | aip650_show_buff[1]); // com2ÊòæÁ§∫--ËøûÊé•Âà∞ÊåâÈîÆÂØπÂ∫îÁöÑLED
 140   1          aip650_write_cmd(0x6E00 | aip650_show_buff[2]); // com3ÊòæÁ§∫--ËøûÊé•Âà∞Á¨¨‰∏Ä‰∏™Êï∞Á†ÅÁÆ°(‰ªéÂ∑¶ÂæÄÂè
             -≥Êï∞)
 141   1      }
 142          
 143          // Âêëaip650ÁöÑÊòæÂ≠òÂÜôÂÖ•Ë¶ÅÊòæÁ§∫ÁöÑÊï∞Â≠ó,
 144          // Â¶ÇÊûú‰º†ÂèÇ == 0xFFÔºåÂàôÊ∏ÖÁ©∫Ë¶ÅÊòæÁ§∫ÁöÑÊï∞Â≠óÔºå‰∏çÂΩ±ÂìçÂ∞èÊï∞ÁÇπÁöÑÊòæÁ§∫
 145          // Â¶ÇÊûú‰º†ÂÖ•‰∫ÜË∂ÖÂá∫ËåÉÂõ¥ÁöÑÂèÇÊï∞ÔºåÊï¥‰∏™aip650ÊòæÂ≠òÂ∞ÜË¢´Ê∏ÖÁ©∫
 146          static void __aip650_show_data(u8 data_bit1, u8 data_bit0)
 147          {
 148   1          // if ((0xFF != data_bit0 && data_bit0 > (sizeof(aip650_data_map_buf) - 1)) ||
 149   1          //     (0xFF != data_bit1 && data_bit1 > (sizeof(aip650_data_map_buf) - 1)))
 150   1          // {
 151   1          //     // Êï∞ÂÄºË∂ÖÂá∫‰∫ÜLEDËÉΩÂ§üÊòæÁ§∫ÁöÑËåÉÂõ¥ÔºåÊ∏ÖÁ©∫ÊòæÁ§∫
 152   1          //     aip650_show_buff[2] = 0;
 153   1          //     aip650_show_buff[0] = 0;
 154   1          //     // aip650_show_refresh();
 155   1          //     return;
 156   1          // }
 157   1      
 158   1          if (0xFF == data_bit0)
 159   1          {
 160   2              aip650_show_buff[0] &= ~0xF7;
 161   2          }
 162   1      
 163   1          if (0xFF == data_bit1)
 164   1          {
 165   2              aip650_show_buff[2] &= ~0xF7;
 166   2          }
 167   1      
 168   1          if (0xFF != data_bit0)
 169   1          {
 170   2              aip650_show_buff[0] = aip650_data_map_buf[data_bit0];
 171   2          }
 172   1      
 173   1          if (0xFF != data_bit1)
C51 COMPILER V9.60.7.0   AIP650                                                            12/02/2024 16:50:47 PAGE 4   

 174   1          {
 175   2              aip650_show_buff[2] = aip650_data_map_buf[data_bit1];
 176   2          }
 177   1      }
 178          
 179          // Âêëaip650ÊòæÂ≠òÂÜôÂÖ•Ë¶ÅÊòæÁ§∫ÁöÑÂ∞èÊï∞ÁÇπ
 180          // ÂèÇÊï∞-locateÔºå 0--‰∏çÊòæÁ§∫Â∞èÊï∞ÁÇπÔºå
 181          //              1--ÊòæÁ§∫Á¨¨‰∏Ä‰∏™Â∞èÊï∞ÁÇπÔºà‰ªéÂ∑¶ÂæÄÂè≥Êï∞Ôºâ,
 182          //              2--ÊòæÁ§∫Á¨¨‰∫å‰∏™Â∞èÊï∞ÁÇπ(‰ªéÂ∑¶ÂæÄÂè≥Êï∞),
 183          //              3--‰∏§‰∏™Â∞èÊï∞ÁÇπÈÉΩÊòæÁ§∫
 184          //             Â¶ÇÊûú‰º†ÂÖ•‰∫ÜË∂ÖÂá∫ËåÉÂõ¥ÁöÑÂèÇÊï∞ÔºåÊï¥‰∏™aip650ÊòæÂ≠òÂ∞ÜË¢´Ê∏ÖÁ©∫
 185          static void __aip650_show_point(u8 locate)
 186          {
 187   1          if (0 == locate)
 188   1          {
 189   2              aip650_show_buff[2] &= ~0x08;
 190   2              aip650_show_buff[0] &= ~0x08;
 191   2          }
 192   1          else if (1 == locate)
 193   1          {
 194   2              aip650_show_buff[2] |= 0x08;
 195   2              aip650_show_buff[0] &= ~0x08;
 196   2          }
 197   1          else if (2 == locate)
 198   1          {
 199   2              aip650_show_buff[2] &= ~0x08;
 200   2              aip650_show_buff[0] |= 0x08;
 201   2          }
 202   1          else if (3 == locate)
 203   1          {
 204   2              aip650_show_buff[2] |= 0x08;
 205   2              aip650_show_buff[0] |= 0x08;
 206   2          }
 207   1          // else
 208   1          // {
 209   1          //     aip650_show_buff[0] = 0;
 210   1          //     aip650_show_buff[1] = 0;
 211   1          //     aip650_show_buff[2] = 0;
 212   1          // }
 213   1      
 214   1          // aip650_show_refresh();
 215   1      }
 216          
 217          // Âêëaip650ÊòæÂ≠òÂÜôÂÖ•Ë¶ÅÁÇπ‰∫ÆÁöÑËß¶Êë∏ÊåâÈîÆÁöÑÂØπÂ∫îÁöÑLED
 218          // ÂèÇÊï∞Ôºöled_data, ËåÉÂõ¥Ôºö0x00~0x1F,Á¨¨0bitË°®Á§∫ÊåâÈîÆK1ÂØπÂ∫îÁöÑLEDÁöÑÁä∂ÊÄÅÔºå
 219          //                                Á¨¨4bitË°®Á§∫ÊåâÈîÆK5ÂØπÂ∫îÁöÑLEDÁöÑÁä∂ÊÄÅÔºå
 220          //                                0Ë°®Á§∫ÁÜÑÁÅ≠Ôºå1Ë°®Á§∫ÁÇπ‰∫Æ
 221          //      Â¶ÇÊûú‰º†ÂÖ•‰∫ÜË∂ÖÂá∫ËåÉÂõ¥ÁöÑÂèÇÊï∞ÔºåÊï¥‰∏™aip650ÊòæÂ≠òÂ∞ÜË¢´Ê∏ÖÁ©∫
 222          static void __aip650_show_led_of_touch(u8 led_data)
 223          {
 224   1          aip650_show_buff[1] = 0; // Ê∏ÖÁ©∫ÂéüÊù•ÁöÑÊï∞ÊçÆ
 225   1      
 226   1          // if (led_data > 0x1F)
 227   1          // {
 228   1          //     // ‰º†ÂÖ•ÁöÑÊï∞ÊçÆÊ†ºÂºèÊúâËØØÔºåÊ∏ÖÁ©∫ÊòæÁ§∫
 229   1          //     aip650_show_buff[0] = 0;
 230   1          //     // aip650_show_buff[1] = 0;
 231   1          //     aip650_show_buff[2] = 0;
 232   1      
 233   1          //     return;
 234   1          // }
 235   1      
C51 COMPILER V9.60.7.0   AIP650                                                            12/02/2024 16:50:47 PAGE 5   

 236   1          if (led_data & 0x01) // ÊåâÈîÆK1
 237   1          {
 238   2              aip650_show_buff[1] |= 0x04;
 239   2          }
 240   1          else if ((led_data & 0x01) == 0)
 241   1          {
 242   2              aip650_show_buff[1] &= ~0x04;
 243   2          }
 244   1      
 245   1          if ((led_data >> 1) & 0x01) // ÊåâÈîÆK2
 246   1          {
 247   2              aip650_show_buff[1] |= 0x02;
 248   2          }
 249   1          else if (((led_data >> 1) & 0x01) == 0)
 250   1          {
 251   2              aip650_show_buff[1] &= ~0x02;
 252   2          }
 253   1      
 254   1          if ((led_data >> 2) & 0x01) // ÊåâÈîÆK3
 255   1          {
 256   2              aip650_show_buff[1] |= 0x80;
 257   2          }
 258   1          else if (((led_data >> 2) & 0x01) == 0)
 259   1          {
 260   2              aip650_show_buff[1] &= ~0x80;
 261   2          }
 262   1      
 263   1          if ((led_data >> 3) & 0x01) // ÊåâÈîÆK4
 264   1          {
 265   2              aip650_show_buff[1] |= 0x40;
 266   2          }
 267   1          else if (((led_data >> 3) & 0x01) == 0)
 268   1          {
 269   2              aip650_show_buff[1] &= ~0x40;
 270   2          }
 271   1      
 272   1          if ((led_data >> 4) & 0x01) // ÊåâÈîÆK5
 273   1          {
 274   2              aip650_show_buff[1] |= 0x20;
 275   2          }
 276   1          else if (((led_data >> 4) & 0x01) == 0)
 277   1          {
 278   2              aip650_show_buff[1] &= ~0x20;
 279   2          }
 280   1      }
 281          
 282          // 
 283          void aip650_show_handle(instruction_t instruction)
 284          {
 285   1          // ÂØπÊåá‰ª§ËøõË°åÊ£ÄÊü•ÔºåÊòØÂê¶Á¨¶ÂêàÂçèËÆÆÁöÑÊ†ºÂºè
 286   1          if ((0xFF != instruction.seg1 && instruction.seg1 > (sizeof(aip650_data_map_buf) - 1)) ||
 287   1              (0xFF != instruction.seg2 && instruction.seg2 > (sizeof(aip650_data_map_buf) - 1)) ||
 288   1              (instruction.point > 0x03) ||
 289   1              (instruction.led > 0x1F) /* Êï∞ÂÄºË∂ÖÂá∫‰∫ÜLEDËÉΩÂ§üÊòæÁ§∫ÁöÑËåÉÂõ¥ */)
 290   1          {
 291   2              // Ê∏ÖÁ©∫ÊòæÁ§∫ÔºåÁÑ∂ÂêéÈÄÄÂá∫
 292   2              memset(aip650_show_buff, 0x00, ARRAY_SIZE(aip650_show_buff));
 293   2              aip650_show_refresh();
 294   2              return;
 295   2          }
 296   1      
 297   1          __aip650_show_data(instruction.seg1, instruction.seg2);
C51 COMPILER V9.60.7.0   AIP650                                                            12/02/2024 16:50:47 PAGE 6   

 298   1          __aip650_show_point(instruction.point);
 299   1          __aip650_show_led_of_touch(instruction.led);
 300   1          aip650_show_refresh();
 301   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    530    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     21       4
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
