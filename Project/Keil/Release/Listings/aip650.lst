C51 COMPILER V9.60.7.0   AIP650                                                            11/11/2024 17:38:10 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE AIP650
OBJECT MODULE PLACED IN .\Release\Objects\aip650.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\Hardware\aip650.c LARGE OPTIMIZE(8,SPEED) BROWSE INTVECTOR(0X000C)
                    - INCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release
                    -\Listings\aip650.lst) OBJECT(.\Release\Objects\aip650.obj)

line level    source

   1          #include "aip650.h"
   2          #include <string.h>
   3          
   4          // 0 1 2 3 4 5 6 7 8 9 NULL -
   5          // u8 leddata[] = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F, 0x00, 0x40};
   6          
   7          /*
   8              //[0]-- com1æ˜¾ç¤º--è¿žæŽ¥åˆ°ç¬¬äºŒä¸ªæ•°ç ç®¡(ä»Žå·¦å¾€å³æ•°)
   9              //[1]-- com2æ˜¾ç¤º--è¿žæŽ¥åˆ°æŒ‰é”®å¯¹åº”çš„LED
  10              //[2]-- com3æ˜¾ç¤º--è¿žæŽ¥åˆ°ç¬¬ä¸€ä¸ªæ•°ç ç®¡(ä»Žå·¦å¾€å³æ•°)
  11          */
  12          u8 aip650_show_buff[3] = {0}; // aip650æ˜¾ç¤ºç¼“å†²åŒºï¼ˆæ˜¾å­˜ï¼‰
  13          
  14          // å­˜æ”¾è¦æ˜¾ç¤ºçš„å†…å®¹
  15          const u8 aip650_data_map_buf[] = {
  16              0xE7, // 0
  17              0x81, // 1
  18              0x75, // 2
  19              0xB5, // 3
  20              0x93, // 4
  21              0xB6, // 5
  22              0xF6, // 6
  23              0x85, // 7
  24              0xF7, // 8
  25              0xB7, // 9
  26          
  27              0x66, // å¤§å†™ "C"
  28              0xF1, // å°å†™ "d"
  29              0x56, // å¤§å†™ "F"
  30              0xD3, // å¤§å†™ "H"
  31              0x62, // å¤§å†™ "L"
  32              0xC7, // å°å†™ "n"
  33          };
  34          
  35          /*æŒ‡ä»¤é›†*/
  36          
  37          // 4801--ç³»ç»Ÿä½¿èƒ½ï¼Œ8æ®µæ˜¾ç¤ºï¼Œ8çº§äº®åº¦
  38          #define SYS_CMD 0x4801
  39          
  40          void aip650_config(void)
  41          {
  42   1          // 14è„š-P16-IIC_DATA
  43   1          // 15è„š-P15-IIC_CLK
  44   1          P1_MD1 &= ~((GPIO_P15_MODE_SEL(0x03)) | (GPIO_P16_MODE_SEL(0x03))); //
  45   1          P1_MD1 |= ((GPIO_P15_MODE_SEL(0x02)) | (GPIO_P16_MODE_SEL(0x02)));  // é…ç½®ä¸ºæ•°å­—å¤ç”¨æ¨¡å¼
  46   1          P1_PU |= (GPIO_P15_PULL_UP(0x01) | GPIO_P16_PULL_UP(0x01));         // ä¸Šæ‹‰
  47   1          P1_ODN |= (GPIO_P15_ODN_EN(0x01) | GPIO_P16_ODN_EN(0x01));          // å¼€æ¼
  48   1          P1_AF0 |= (GPIO_P15_FUNC_SEL(0x01) | GPIO_P16_FUNC_SEL(0x01));      // P15ä½œä¸ºIIC_CLK, P16ä½œä¸ºIIC_
             -DATA
  49   1      
  50   1          I2C_CON = I2C_CR_SEL(0x02); // é…ç½®æ³¢ç‰¹çŽ‡ï¼Œå¯æ ¹æ®è¡¨æ ¼è‡ªè¡Œé€‰æ‹©
  51   1          I2C_CON |= I2C_EN(0x1);     // ä½¿èƒ½æ¨¡å—
  52   1      
C51 COMPILER V9.60.7.0   AIP650                                                            11/11/2024 17:38:10 PAGE 2   

  53   1          // memset(sg_650e_drv._buf, 0x00, AIP650E_SIZE);
  54   1          // aip650e_update(&sg_650e_drv); // ä¸Šç”µç¬¬ä¸€æ¬¡æ¸…ç©ºæ˜¾ç¤º
  55   1      }
  56          
  57          /**
  58           * @brief  IIC sends 1 byte data function
  59           * @param  iic_data: IIC data
  60           * @param  flag: 0: None  1:send start   2:send stop
  61           * @retval Returns 1 and receives an ACK
  62           */
  63          static u8 iic_master_tx(u8 iic_data, u8 flag)
  64          {
  65   1      #define START_FLAG (1)
  66   1      #define STOP_FLAG (2)
  67   1      
  68   1          u8 ack_flag = 0;
  69   1      
  70   1          if (flag == START_FLAG)
  71   1          {
  72   2              // é…ç½®å‘é€èµ·å§‹ä½
  73   2              I2C_CON |= (I2C_START_BIT(0x1) | I2C_SI_CLEAR(0x1));
  74   2              // ç­‰å¾… SI ç½® 1ï¼Œ èµ·å§‹ä½å‘é€æˆåŠŸæ—¶ä¼šç½® 1ï¼Œ å…¶å®ƒæƒ…å†µä¹Ÿå¯èƒ½ä¼šç½® 1ï¼Œ éœ€è¦æ
             -³¨æ„
  75   2              while (!(I2C_STA & I2C_SI_STA(0x1)))
  76   2                  ;
  77   2              I2C_CON &= ~I2C_START_BIT(0x1);
  78   2      
  79   2              // åˆ¤æ–­æ¨¡å—çŠ¶æ€
  80   2              if (!(((I2C_STA & I2C_STA_FLAG(0x1F)) == 0x08) ||
  81   2                    ((I2C_STA & I2C_STA_FLAG(0x1F)) == 0x10)))
  82   2              {
  83   3                  return 0;
  84   3              }
  85   2          }
  86   1      
  87   1          // å†™å…¥ç›®æ ‡ä»Žæœºåœ°å€
  88   1          I2C_DATA = iic_data;
  89   1          // ç­‰å¾…åœ°å€å‘é€å®Œæˆ
  90   1          while (!(I2C_STA & I2C_SI_STA(0x1)))
  91   1              ;
  92   1      
  93   1          // åˆ¤æ–­æ˜¯å¦æ”¶åˆ° ACK
  94   1          if (((I2C_STA & I2C_STA_FLAG(0x1F)) == 0x18) ||
  95   1              ((I2C_STA & I2C_STA_FLAG(0x1F)) == 0x28) ||
  96   1              ((I2C_STA & I2C_STA_FLAG(0x1F)) == 0x40))
  97   1          {
  98   2              ack_flag = 1;
  99   2          }
 100   1          else
 101   1          {
 102   2              ack_flag = 0;
 103   2          }
 104   1      
 105   1          if (flag == STOP_FLAG)
 106   1          {
 107   2              // é…ç½®å‘é€åœæ­¢ä½
 108   2              I2C_CON |= (I2C_STOP_BIT(0x1) | I2C_SI_CLEAR(0x1));
 109   2          }
 110   1      
 111   1          return ack_flag;
 112   1      }
 113          
C51 COMPILER V9.60.7.0   AIP650                                                            11/11/2024 17:38:10 PAGE 3   

 114          static void aip650_write_cmd(u16 cmd) //
 115          {
 116   1          iic_master_tx(cmd >> 8, 1);
 117   1          iic_master_tx(cmd & 0xFF, 2);
 118   1      }
 119          
 120          // // æ›´æ–°aip650çš„æ˜¾å­˜
 121          // void aip650_show_buff_update(u8 *buff)
 122          // {
 123          //     aip650_show_buff[0] = (aip650_show_buff[0] & ~0xFF) | buff[0];
 124          //     aip650_show_buff[1] = (aip650_show_buff[1] & ~0xFF) | buff[1];
 125          //     aip650_show_buff[2] = (aip650_show_buff[2] & ~0xFF) | buff[2];
 126          // }
 127          
 128          // åˆ·æ–°aip650è¦æ˜¾ç¤ºçš„å†…å®¹(å°†aip650æ˜¾å­˜çš„å†…å®¹æ›´æ–°åˆ°å¤–è®¾ä¸Š)
 129          void aip650_show_refresh(void)
 130          {
 131   1          aip650_write_cmd(SYS_CMD); // å¼€æ˜¾ç¤ºï¼Œ8çº§æ˜¾ç¤º(0x4801);ç¡çœ ä½¿èƒ½ã€‚æ—¶é’ŸåœæŒ¯(0x4804)
 132   1      
 133   1          // aip650_write_cmd(0x6800 | aip650_show_buff[0]); // com0æ˜¾ç¤º--æœªè¿žæŽ¥ä»»ä½•ç¡¬ä»¶
 134   1          aip650_write_cmd(0x6A00 | aip650_show_buff[0]); // com1æ˜¾ç¤º--è¿žæŽ¥åˆ°ç¬¬äºŒä¸ªæ•°ç ç®¡(ä»Žå·¦å¾€å
             -³æ•°)
 135   1          aip650_write_cmd(0x6C00 | aip650_show_buff[1]); // com2æ˜¾ç¤º--è¿žæŽ¥åˆ°æŒ‰é”®å¯¹åº”çš„LED
 136   1          aip650_write_cmd(0x6E00 | aip650_show_buff[2]); // com3æ˜¾ç¤º--è¿žæŽ¥åˆ°ç¬¬ä¸€ä¸ªæ•°ç ç®¡(ä»Žå·¦å¾€å
             -³æ•°)
 137   1      }
 138          
 139          // å‘aip650çš„æ˜¾å­˜å†™å…¥è¦æ˜¾ç¤ºçš„æ•°å­—,
 140          // å¦‚æžœä¼ å‚ == 0xFFï¼Œåˆ™æ¸…ç©ºè¦æ˜¾ç¤ºçš„æ•°å­—ï¼Œä¸å½±å“å°æ•°ç‚¹çš„æ˜¾ç¤º
 141          // å¦‚æžœä¼ å…¥äº†è¶…å‡ºèŒƒå›´çš„å‚æ•°ï¼Œæ•´ä¸ªaip650æ˜¾å­˜å°†è¢«æ¸…ç©º
 142          void aip650_show_data(u8 data_bit1, u8 data_bit0)
 143          {
 144   1          if ((0xFF != data_bit0 && data_bit0 > (sizeof(aip650_data_map_buf) - 1)) ||
 145   1              (0xFF != data_bit1 && data_bit1 > (sizeof(aip650_data_map_buf) - 1)))
 146   1          {
 147   2              // æ•°å€¼è¶…å‡ºäº†LEDèƒ½å¤Ÿæ˜¾ç¤ºçš„èŒƒå›´ï¼Œæ¸…ç©ºæ˜¾ç¤º
 148   2              aip650_show_buff[2] = 0;
 149   2              aip650_show_buff[0] = 0;
 150   2              // aip650_show_refresh();
 151   2              return;
 152   2          }
 153   1      
 154   1          if (0xFF == data_bit0)
 155   1          {
 156   2              aip650_show_buff[0] &= ~0xF7;
 157   2          }
 158   1      
 159   1          if (0xFF == data_bit1)
 160   1          {
 161   2              aip650_show_buff[2] &= ~0xF7;
 162   2          }
 163   1      
 164   1          if (0xFF != data_bit0)
 165   1          {
 166   2              aip650_show_buff[0] = aip650_data_map_buf[data_bit0];
 167   2          }
 168   1      
 169   1          if (0xFF != data_bit1)
 170   1          {
 171   2              aip650_show_buff[2] = aip650_data_map_buf[data_bit1];
 172   2          }
 173   1      }
C51 COMPILER V9.60.7.0   AIP650                                                            11/11/2024 17:38:10 PAGE 4   

 174          
 175          // å‘aip650æ˜¾å­˜å†™å…¥è¦æ˜¾ç¤ºçš„å°æ•°ç‚¹
 176          // å‚æ•°-locateï¼Œ 0--ä¸æ˜¾ç¤ºå°æ•°ç‚¹ï¼Œ
 177          //              1--æ˜¾ç¤ºç¬¬ä¸€ä¸ªå°æ•°ç‚¹ï¼ˆä»Žå·¦å¾€å³æ•°ï¼‰,
 178          //              2--æ˜¾ç¤ºç¬¬äºŒä¸ªå°æ•°ç‚¹(ä»Žå·¦å¾€å³æ•°),
 179          //              3--ä¸¤ä¸ªå°æ•°ç‚¹éƒ½æ˜¾ç¤º
 180          //             å¦‚æžœä¼ å…¥äº†è¶…å‡ºèŒƒå›´çš„å‚æ•°ï¼Œæ•´ä¸ªaip650æ˜¾å­˜å°†è¢«æ¸…ç©º
 181          void aip650_show_point(u8 locate)
 182          {
 183   1          if (0 == locate)
 184   1          {
 185   2              aip650_show_buff[2] &= ~0x08;
 186   2              aip650_show_buff[0] &= ~0x08;
 187   2          }
 188   1          else if (1 == locate)
 189   1          {
 190   2              aip650_show_buff[2] |= 0x08;
 191   2              aip650_show_buff[0] &= ~0x08;
 192   2          }
 193   1          else if (2 == locate)
 194   1          {
 195   2              aip650_show_buff[2] &= ~0x08;
 196   2              aip650_show_buff[0] |= 0x08;
 197   2          }
 198   1          else if (3 == locate)
 199   1          {
 200   2              aip650_show_buff[2] |= 0x08;
 201   2              aip650_show_buff[0] |= 0x08;
 202   2          }
 203   1          else
 204   1          {
 205   2              aip650_show_buff[0] = 0;
 206   2              aip650_show_buff[1] = 0;
 207   2              aip650_show_buff[2] = 0;
 208   2          }
 209   1      
 210   1          // aip650_show_refresh();
 211   1      }
 212          
 213          // å‘aip650æ˜¾å­˜å†™å…¥è¦ç‚¹äº®çš„è§¦æ‘¸æŒ‰é”®çš„å¯¹åº”çš„LED
 214          // å‚æ•°ï¼šled_data, èŒƒå›´ï¼š0x00~0x1F,ç¬¬0bitè¡¨ç¤ºæŒ‰é”®K1å¯¹åº”çš„LEDçš„çŠ¶æ€ï¼Œ
 215          //                                ç¬¬4bitè¡¨ç¤ºæŒ‰é”®K5å¯¹åº”çš„LEDçš„çŠ¶æ€ï¼Œ
 216          //                                0è¡¨ç¤ºç†„ç­ï¼Œ1è¡¨ç¤ºç‚¹äº®
 217          //      å¦‚æžœä¼ å…¥äº†è¶…å‡ºèŒƒå›´çš„å‚æ•°ï¼Œæ•´ä¸ªaip650æ˜¾å­˜å°†è¢«æ¸…ç©º
 218          void aip650_show_led_of_touch(u8 led_data)
 219          {   
 220   1          aip650_show_buff[1] = 0; // æ¸…ç©ºåŽŸæ¥çš„æ•°æ®
 221   1      
 222   1          if (led_data > 0x1F)
 223   1          {
 224   2              // ä¼ å…¥çš„æ•°æ®æ ¼å¼æœ‰è¯¯ï¼Œæ¸…ç©ºæ˜¾ç¤º
 225   2              aip650_show_buff[0] = 0;
 226   2              // aip650_show_buff[1] = 0;
 227   2              aip650_show_buff[2] = 0;
 228   2              return;
 229   2          }
 230   1      
 231   1          if (led_data & 0x01) // æŒ‰é”®K1
 232   1          {
 233   2              aip650_show_buff[1] |= 0x04;
 234   2          }
 235   1          else if ((led_data & 0x01) == 0)
C51 COMPILER V9.60.7.0   AIP650                                                            11/11/2024 17:38:10 PAGE 5   

 236   1          {
 237   2              aip650_show_buff[1] &= ~0x04;
 238   2          }
 239   1      
 240   1          if ((led_data >> 1) & 0x01) // æŒ‰é”®K2
 241   1          {
 242   2              aip650_show_buff[1] |= 0x02;
 243   2          }
 244   1          else if (((led_data >> 1) & 0x01) == 0)
 245   1          {
 246   2              aip650_show_buff[1] &= ~0x02;
 247   2          }
 248   1      
 249   1          if ((led_data >> 2) & 0x01) // æŒ‰é”®K3
 250   1          {
 251   2              aip650_show_buff[1] |= 0x80;
 252   2          }
 253   1          else if (((led_data >> 2) & 0x01) == 0)
 254   1          {
 255   2              aip650_show_buff[1] &= ~0x80;
 256   2          }
 257   1      
 258   1          if ((led_data >> 3) & 0x01) // æŒ‰é”®K4
 259   1          {
 260   2              aip650_show_buff[1] |= 0x40;
 261   2          }
 262   1          else if (((led_data >> 3) & 0x01) == 0)
 263   1          {
 264   2              aip650_show_buff[1] &= ~0x40;
 265   2          }
 266   1      
 267   1          if ((led_data >> 4) & 0x01) // æŒ‰é”®K5
 268   1          {
 269   2              aip650_show_buff[1] |= 0x20;
 270   2          }
 271   1          else if (((led_data >> 4) & 0x01) == 0)
 272   1          {
 273   2              aip650_show_buff[1] &= ~0x20;
 274   2          }
 275   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    498    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     19    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
