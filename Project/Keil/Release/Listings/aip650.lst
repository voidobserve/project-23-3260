C51 COMPILER V9.60.7.0   AIP650                                                            11/09/2024 16:51:57 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE AIP650
OBJECT MODULE PLACED IN .\Release\Objects\aip650.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\Hardware\aip650.c LARGE OPTIMIZE(8,SPEED) BROWSE INTVECTOR(0X000C)
                    - INCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release
                    -\Listings\aip650.lst) OBJECT(.\Release\Objects\aip650.obj)

line level    source

   1          #include "aip650.h"
   2          #include <string.h>
   3          
   4          void aip650_config(void)
   5          {
   6   1          // 14ËÑö-P16-IIC_DATA
   7   1          // 15ËÑö-P15-IIC_CLK
   8   1          P1_MD1 &= ~((GPIO_P15_MODE_SEL(0x03)) | (GPIO_P16_MODE_SEL(0x03))); //
   9   1          P1_MD1 |= ((GPIO_P15_MODE_SEL(0x02)) | (GPIO_P16_MODE_SEL(0x02)));  // ÈÖçÁΩÆ‰∏∫Êï∞Â≠óÂ§çÁî®Ê®°Âºè
  10   1          P1_PU |= (GPIO_P15_PULL_UP(0x01) | GPIO_P16_PULL_UP(0x01));         // ‰∏äÊãâ
  11   1          P1_ODN |= (GPIO_P15_ODN_EN(0x01) | GPIO_P16_ODN_EN(0x01));          // ÂºÄÊºè
  12   1          P1_AF0 |= (GPIO_P15_FUNC_SEL(0x01) | GPIO_P16_FUNC_SEL(0x01));      // P15‰Ωú‰∏∫IIC_CLK, P16‰Ωú‰∏∫IIC_
             -DATA
  13   1      
  14   1          I2C_CON = I2C_CR_SEL(0x02); // ÈÖçÁΩÆÊ≥¢ÁâπÁéáÔºåÂèØÊ†πÊçÆË°®Ê†ºËá™Ë°åÈÄâÊã©
  15   1          I2C_CON |= I2C_EN(0x1);     // ‰ΩøËÉΩÊ®°Âùó
  16   1      }
  17          
  18          /**
  19           * @brief  IIC sends 1 byte data function
  20           * @param  iic_data: IIC data
  21           * @param  flag: 0: None  1:send start   2:send stop
  22           * @retval Returns 1 and receives an ACK
  23           */
  24          u8 iic_master_tx(u8 iic_data, u8 flag)
  25          {
  26   1      #define START_FLAG (1)
  27   1      #define STOP_FLAG (2)
  28   1      
  29   1          u8 ack_flag = 0;
  30   1      
  31   1          if (flag == START_FLAG)
  32   1          {
  33   2              // ÈÖçÁΩÆÂèëÈÄÅËµ∑Âßã‰Ωç
  34   2              I2C_CON |= (I2C_START_BIT(0x1) | I2C_SI_CLEAR(0x1));
  35   2              // Á≠âÂæÖ SI ÁΩÆ 1Ôºå Ëµ∑Âßã‰ΩçÂèëÈÄÅÊàêÂäüÊó∂‰ºöÁΩÆ 1Ôºå ÂÖ∂ÂÆÉÊÉÖÂÜµ‰πüÂèØËÉΩ‰ºöÁΩÆ 1Ôºå ÈúÄË¶ÅÊ
             -≥®ÊÑè
  36   2              while (!(I2C_STA & I2C_SI_STA(0x1)))
  37   2                  ;
  38   2              I2C_CON &= ~I2C_START_BIT(0x1);
  39   2      
  40   2              // Âà§Êñ≠Ê®°ÂùóÁä∂ÊÄÅ
  41   2              if (!(((I2C_STA & I2C_STA_FLAG(0x1F)) == 0x08) ||
  42   2                    ((I2C_STA & I2C_STA_FLAG(0x1F)) == 0x10)))
  43   2              {
  44   3                  return 0;
  45   3              }
  46   2          }
  47   1      
  48   1          // ÂÜôÂÖ•ÁõÆÊ†á‰ªéÊú∫Âú∞ÂùÄ
  49   1          I2C_DATA = iic_data;
  50   1          // Á≠âÂæÖÂú∞ÂùÄÂèëÈÄÅÂÆåÊàê
  51   1          while (!(I2C_STA & I2C_SI_STA(0x1)))
C51 COMPILER V9.60.7.0   AIP650                                                            11/09/2024 16:51:57 PAGE 2   

  52   1              ;
  53   1      
  54   1          // Âà§Êñ≠ÊòØÂê¶Êî∂Âà∞ ACK
  55   1          if (((I2C_STA & I2C_STA_FLAG(0x1F)) == 0x18) ||
  56   1              ((I2C_STA & I2C_STA_FLAG(0x1F)) == 0x28) ||
  57   1              ((I2C_STA & I2C_STA_FLAG(0x1F)) == 0x40))
  58   1          {
  59   2              ack_flag = 1;
  60   2          }
  61   1          else
  62   1          {
  63   2              ack_flag = 0;
  64   2          }
  65   1      
  66   1          if (flag == STOP_FLAG)
  67   1          {
  68   2              // ÈÖçÁΩÆÂèëÈÄÅÂÅúÊ≠¢‰Ωç
  69   2              I2C_CON |= (I2C_STOP_BIT(0x1) | I2C_SI_CLEAR(0x1));
  70   2          }
  71   1      
  72   1          return ack_flag;
  73   1      }
  74          
  75          struct _650e_drv_ sg_650e_drv;
  76          
  77          // 0 1 2 3 4 5 6 7 8 9 NULL -
  78          u8 leddata[] = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F, 0x00, 0x40};
  79          
  80          /*Êåá‰ª§ÈõÜ*/
  81          #define SYS_CMD 0x4801 // 48ÊòØÁ≥ªÁªüÊåá‰ª§ÔºåËÆæÁΩÆÁ≥ªÁªüÂèÇÊï∞        Ôºõ01ÊòØÊòæÁ§∫Êåá‰ª§ÔºåËÆæÁΩÆ‰∏∫Â∑•‰ΩúÊ®°
             -ÂºèÔºå8ÊÆµÊòæÁ§∫Ôºå8Á∫ß‰∫ÆÂ∫¶ÔºåÊòæÁ§∫ÂºÄ
  82          
  83          void aip650e_init(struct _650e_drv_ *drv)
  84          {
  85   1          memset(drv->_buf, 0x00, AIP650E_SIZE);
  86   1          aip650e_update(drv); // ‰∏äÁîµÁ¨¨‰∏ÄÊ¨°Ê∏ÖÁ©∫ÊòæÁ§∫
  87   1      }
  88          
  89          /*Âª∂Êó∂ÊúÄÂ∞èÂçïÂÖÉ*/
  90          // #define TIME_UINT 1
  91          
  92          // static void delay_us(uint32_t nus)
  93          // {
  94          //      uint32_t Delay = nus;
  95          //      do
  96          //      {
  97          //              __NOP();
  98          //      } while (Delay--);
  99          // }
 100          
 101          // IICÂºÄÂßã‰ø°Âè∑
 102          // static void start_i2c(void)
 103          // {
 104          //      SDA_SET;
 105          //      delay_us(TIME_UINT);
 106          //      SCL_SET;
 107          //      delay_us(TIME_UINT);
 108          //      SDA_RESET;
 109          //      delay_us(TIME_UINT);
 110          //      SCL_RESET;
 111          //      delay_us(TIME_UINT);
 112          // }
C51 COMPILER V9.60.7.0   AIP650                                                            11/09/2024 16:51:57 PAGE 3   

 113          
 114          // static void stop_i2c(void)
 115          //  IICÂÅúÊ≠¢‰ø°Âè∑
 116          //{
 117          //      SCL_SET;
 118          //      delay_us(TIME_UINT);
 119          //      SDA_RESET;
 120          //      delay_us(TIME_UINT);
 121          //      SDA_SET;
 122          //      delay_us(TIME_UINT);
 123          //      SDA_RESET;
 124          //      SCL_RESET;
 125          //}
 126          
 127          // // Êï∞ÊçÆ‰º†Ëæì-‰º†ÈÄÅ‰∏Ä‰∏™Â≠óËäÇ, ÂÖàËØªÈ´ò‰Ωç
 128          // static void send_byte(unsigned char dat)
 129          // {
 130          //      unsigned char i;
 131          //      for (i = 0; i < 8; i++)
 132          //      {
 133          //              SCL_RESET;
 134          //              if (dat & 0x80)
 135          //              {
 136          //                      SDA_SET;
 137          //              }
 138          //              else
 139          //              {
 140          //                      SDA_RESET;
 141          //              }
 142          //              SCL_SET;
 143          //              dat = dat << 1;
 144          //      }
 145          //      SCL_RESET;
 146          //      delay_us(TIME_UINT);
 147          //      SDA_RESET; // ACK‰ø°Âè∑
 148          //      delay_us(TIME_UINT);
 149          //      SCL_SET;
 150          //      delay_us(TIME_UINT);
 151          //      delay_us(TIME_UINT);
 152          //      SCL_RESET;
 153          //      delay_us(TIME_UINT);
 154          // }
 155          
 156          static void writeCMD(u16 cmd)
 157          {
 158   1          // start_i2c();
 159   1          // send_byte(cmd >> 8);
 160   1          // send_byte(cmd & 0xff);
 161   1          // wait_ack_i2c();
 162   1      
 163   1          iic_master_tx(cmd >> 8, 1);
 164   1          iic_master_tx(cmd & 0xFF, 2);
 165   1      }
 166          
 167          // /// @brief ÊòæÁ§∫Êï∞ÊçÆÊõ¥Êñ∞
 168          // /// @param drv
 169          
 170          u8 test_i = 0;
 171          u8 temp = 0;
 172          void aip650e_display_update(struct _650e_drv_ *drv)
 173          {
 174   1          temp = 1;
C51 COMPILER V9.60.7.0   AIP650                                                            11/09/2024 16:51:57 PAGE 4   

 175   1          // Ê∏©Â∫¶ÊòæÁ§∫
 176   1          switch (temp)
 177   1          {
 178   2          case 0:
 179   2              // Ê∏©Â∫¶ÊòæÁ§∫---
 180   2              drv->_buf[0] = (drv->_buf[0] & ~0x7f) | leddata[11]; // -
 181   2              drv->_buf[1] = (drv->_buf[1] & ~0x7f) | leddata[11];
 182   2              drv->_buf[2] = (drv->_buf[2] & ~0x7f) | leddata[11];
 183   2              break;
 184   2          case 1:
 185   2              // Ê∏©Â∫¶ÊòæÁ§∫60
 186   2              drv->_buf[0] = (drv->_buf[0] & ~0x7f) | leddata[10]; // null
 187   2              drv->_buf[1] = (drv->_buf[1] & ~0x7f) | leddata[6];
 188   2              drv->_buf[2] = (drv->_buf[2] & ~0x7f) | leddata[0];
 189   2              break;
 190   2          case 2:
 191   2              // Ê∏©Â∫¶ÊòæÁ§∫90
 192   2              drv->_buf[0] = (drv->_buf[0] & ~0x7f) | leddata[10]; // null
 193   2              drv->_buf[1] = (drv->_buf[1] & ~0x7f) | leddata[9];
 194   2              drv->_buf[2] = (drv->_buf[2] & ~0x7f) | leddata[0];
 195   2              break;
 196   2          case 3:
 197   2              // Ê∏©Â∫¶ÊòæÁ§∫120
 198   2              drv->_buf[0] = (drv->_buf[0] & ~0x7f) | leddata[1];
 199   2              drv->_buf[1] = (drv->_buf[1] & ~0x7f) | leddata[2];
 200   2              drv->_buf[2] = (drv->_buf[2] & ~0x7f) | leddata[0];
 201   2              break;
 202   2          default:
 203   2              break;
 204   2          }
 205   1      
 206   1      #ifdef AIP650_TEST_MODE
 207   1          drv->_buf[0] = (drv->_buf[0] & ~0x7f) | leddata[test_i];
 208   1          drv->_buf[1] = (drv->_buf[1] & ~0x7f) | leddata[test_i];
 209   1          drv->_buf[2] = (drv->_buf[2] & ~0x7f) | leddata[test_i];
 210   1      
 211   1          test_i++;
 212   1          if (test_i > 9)
 213   1              test_i = 0;
 214   1      #endif
 215   1      }
 216          
 217          /// @brief Âà∑Êñ∞Â±èÊòæ
 218          /// @param drv
 219          void aip650e_update(struct _650e_drv_ *drv)
 220          {
 221   1          writeCMD(SYS_CMD); // ÂºÄÊòæÁ§∫Ôºå8Á∫ßÊòæÁ§∫(0x4801);Áù°Áú†‰ΩøËÉΩ„ÄÇÊó∂ÈíüÂÅúÊåØ(0x4804)
 222   1      
 223   1          writeCMD(0x6800 | drv->_buf[0]); // com0ÊòæÁ§∫
 224   1          writeCMD(0x6A00 | drv->_buf[1]); // com1ÊòæÁ§∫
 225   1          writeCMD(0x6C00 | drv->_buf[2]); // com2ÊòæÁ§∫
 226   1          writeCMD(0x6E00 | drv->_buf[3]); // com3ÊòæÁ§∫
 227   1      }
 228          
 229          #ifdef AIP650_TEST_MODE
 230          static void test_display(u8 data1, u8 data2, u8 data3, u8 data4)
 231          {
 232   1          writeCMD(SYS_CMD); // ÂºÄÊòæÁ§∫Ôºå8Á∫ßÊòæÁ§∫(0x4801);Áù°Áú†‰ΩøËÉΩ„ÄÇÊó∂ÈíüÂÅúÊåØ(0x4804)
 233   1      
 234   1          writeCMD(0x6800 | data1); // com0 ÊòæÁ§∫
 235   1          writeCMD(0x6A00 | data3); // com1ÊòæÁ§∫
 236   1          writeCMD(0x6C00 | data2); // com2ÊòæÁ§∫
C51 COMPILER V9.60.7.0   AIP650                                                            11/09/2024 16:51:57 PAGE 5   

 237   1          writeCMD(0x6E00 | data4); // com3ÊòæÁ§∫
 238   1      }
 239          
 240          /// @brief ÊµãËØïÁ®ãÂ∫è
 241          /// @param
 242          uint8 test_dat = 0x01;
 243          void test_aip650e(void)
 244          {
 245   1          test_display(test_dat,
 246   1                       test_dat,
 247   1                       test_dat,
 248   1                       test_dat);
 249   1      
 250   1          test_dat = test_dat << 1;
 251   1      
 252   1          if (test_dat == 0)
 253   1          {
 254   2              test_dat = 0x01;
 255   2          }
 256   1      }
 257          #endif
 258          
 259          /**
 260           * @brief  IIC receive 1 byte data function
 261           * @param  ack_en: 0:Send NACK  1:Send ACK   2:Send stop
 262           * @retval Returns data
 263           */
 264          // static u8 iic_master_rx(u8 flag)
 265          // {
 266          // #define NACK_FLAG (0)
 267          // #define ACK_FLAG (1)
 268          // #define STOP_FLAG (2)
 269          
 270          //     u8 ack_flag = 0;
 271          //     u8 iic_data = 0;
 272          
 273          //     if (flag == ACK_FLAG)
 274          //     {
 275          //         // Êé•Êî∂ÂÆå1byteÊï∞ÊçÆÂèëÈÄÅACK
 276          //         I2C_CON |= I2C_ACK_NACK_BIT(0x1);
 277          //         if (I2C_STA & I2C_SI_STA(0x1))
 278          //         {
 279          //             I2C_CON |= I2C_SI_CLEAR(0x1);
 280          //         }
 281          //     }
 282          
 283          //     // Á≠âÂæÖÊé•Êî∂ÂÆåÊàê
 284          //     while (!(I2C_STA & I2C_SI_STA(0x1)))
 285          //         ;
 286          
 287          //     if (flag == NACK_FLAG)
 288          //     {
 289          //         // Êé•Êî∂ÂÆå1byteÊï∞ÊçÆÂèëÈÄÅNACK
 290          //         I2C_CON &= ~I2C_ACK_NACK_BIT(0x1);
 291          //     }
 292          //     if (flag == STOP_FLAG)
 293          //     {
 294          //         // ÈÖçÁΩÆÂèëÈÄÅÂÅúÊ≠¢‰Ωç
 295          //         I2C_CON |= (I2C_STOP_BIT(0x1) | I2C_SI_CLEAR(0x1));
 296          //     }
 297          
 298          //     // ÂºÄÂèëÊó∂Ê≠§Â§ÑÁöÑÂ§ÑÁêÜÂèØÊ≥®ÈáäÊéâ
C51 COMPILER V9.60.7.0   AIP650                                                            11/09/2024 16:51:57 PAGE 6   

 299          //     if ((I2C_STA & I2C_STA_FLAG(0x1F)) == 0x50)
 300          //     {
 301          //         // ÊàêÂäüÂèëÈÄÅ ACK
 302          //         ack_flag = 1;
 303          //     }
 304          //     else if ((I2C_STA & I2C_STA_FLAG(0x1F)) == 0x58)
 305          //     {
 306          //         // ÊàêÂäüÂèëÈÄÅ NACK
 307          //         ack_flag = 0;
 308          //     }
 309          
 310          //     return I2C_DATA;
 311          // }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    716    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     20      10
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
