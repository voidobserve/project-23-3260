C51 COMPILER V9.60.7.0   RF_LEARN                                                          11/08/2024 17:56:17 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE RF_LEARN
OBJECT MODULE PLACED IN .\Release\Objects\rf_learn.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\rf_learn.c LARGE OPTIMIZE(8,SPEED) BROWSE INTVECTOR(0X000C) I
                    -NCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\rf_lear
                    -n.lst) OBJECT(.\Release\Objects\rf_learn.obj)

line level    source

   1          // Ñ§Ï°¹¦ÄÜ£¨±£´æÆ÷¼şµØÖ·Ïà¹Ø£©µÄÔ´ÎÄ¼ş
   2          #include "rf_learn.h" //
   3          #include "flash.h"    // °üº¬µ¥Æ¬»úµÄflashÏà¹Ø²Ù×÷
   4          #include "rf_recv.h"  // rf½âÂëÏà¹Ø²Ù×÷
   5          #include "send_key.h" // ·¢ËÍ¼üÖµ£¬²âÊÔÊ±ÓÃ
   6          #include "tmr2.h"     // Ê¹ÓÃ¶¨Ê±Æ÷TMR2À´ÊµÏÖ5sÑÓÊ±
   7          
   8          #include <stdlib.h> // Ê¹ÓÃÁËNULL
   9          
  10          addr_info_t addr_info = {0}; // ´æ·Å´ÓflashÖĞ¶Á³öµÄÆ÷¼şµØÖ·
  11          
  12          #ifdef LEARN_BY_QUANTITY // ±£´æn¸öÆ÷¼şµØÖ·
  13          /**
  14           * @brief RFÑ§Ï°¹¦ÄÜ£¬5sÄÚ¼ì²âµ½ÓĞ°´¼ü³¤°´£¬Ôò½«Õâ¸öÒ£¿ØÆ÷µÄÆ÷¼şµØÖ·Ğ´Èëµ½flashÖĞ£¨Ò»°ã·ÅÔÚÉÏµçµÄ5sÖĞÊ¹ÓÃ£
             -©
  15           *          Èç¹û my_config.hÎÄ¼şÖĞµÄUSE_RF_UNPAIRÎª1£¬ÄÇÃ´µ±ÊÕµ½ÓĞÓëflashÖĞÏàÍ¬µÄÆ÷¼şµØÖ·´«À´µÄĞÅºÅÊ±£¬
  16           *          »á´ÓflashÖĞÉ¾³ı¸ÃµØÖ·Êı¾İ£¬ÊµÏÖÈ¡ÏûÅä¶Ô
  17           */
  18          void rf_learn(void)
  19          {
  20   1          u32 appear_themost_ele = 0; // RF½ÓÊÕÊı×éÖĞ³öÏÖ×î¶à´ÎÊıµÄÔªËØ
  21   1      
  22   1          u32 i = 0; // Ñ­»·¼ÆÊıÖµ
  23   1          u32 j = 0; // Ñ­»·¼ÆÊıÖµ
  24   1      
  25   1          bit isSpare = 0; // ±êÖ¾Î»£¬flashÖĞÊÇ·ñÓĞ¿ÕÏĞÎ»ÖÃÀ´´æ´¢¿ÕµÄµØÖ·
  26   1      
  27   1          u32 temp = 0;             // ÁÙÊ±±äÁ¿£¬´æ·ÅÁÙÊ±Öµ
  28   1          u32 the_oldest_index = 0; // ×î¾ÉµÄÆ÷¼şµØÖ·¶ÔÓ¦µÄÊı×éÏÂ±ê
  29   1      
  30   1          // ´ò¿ª¶¨Ê±Æ÷
  31   1          tmr2_enable();
  32   1      
  33   1          while (tmr2_flag != 1)
  34   1          {
  35   2              WDT_KEY = WDT_KEY_VAL(0xAA); // Î¹¹·
  36   2              rf_recv_databuf();           // Ã¿´ÎÑ­»·£¬ÊÔ×Å¶ÁÈ¡Ò»´ÎÊı¾İ
  37   2          }
  38   1      
  39   1          // 5sºó£¬¹Ø±Õ¶¨Ê±Æ÷£¬Çå¿ÕËüÓ²¼şµÄ¼ÆÊıÖµ
  40   1          tmr2_disable();
  41   1          tmr2_flag = 0; // Çå³ı±êÖ¾Î»
  42   1          tmr2_cnt = 0;  // Çå³ı¶¨Ê±Æ÷µÄ¼ÆÊıÖµ
  43   1      
  44   1          // ´ÓflashÖĞ¶ÁÈ¡Æ÷¼şµØÖ·
  45   1          flash_read(FLASH_DEVICE_START_ADDR, (unsigned char *)(&addr_info), sizeof(addr_info));
  46   1      
  47   1          // Èç¹ûÕâ¶ÎÊ±¼äÄÚ¼ì²âµ½ÓĞ°´¼ü³¤°´£¬Ê¹µÃ±êÖ¾Î»ÖÃÒ»£¬½øĞĞÏà¹ØµÄ´¦Àí
  48   1          if (rf_data_buf_overflow)
  49   1          {
  50   2              rf_data_buf_overflow = 0;
  51   2              // ÕÒ³öÊı×éÖĞ³öÏÖ´ÎÊı×î¶àµÄÔªËØ
  52   2              appear_themost(rf_data_buf, sizeof(rf_data_buf) / sizeof(rf_data_buf[0]), &appear_themost_ele, NUL
C51 COMPILER V9.60.7.0   RF_LEARN                                                          11/08/2024 17:56:17 PAGE 2   

             -L);
  53   2      
  54   2              // Èç¹û²»ÊÇµçÔ´°´¼ü(Ñ§Ï°°´¼ü)£¬º¯ÊıÍË³ö
  55   2              if (((appear_themost_ele & 0xFF) != 0x01) && ((appear_themost_ele & 0xFF) != 0x03))
  56   2              {
  57   3                  return;
  58   3              }
  59   2      
  60   2              // Èç¹ûÊÇµçÔ´°´¼ü
  61   2              // ½«Æ÷¼şµØÖ·Ğ´Èëµ½µ¥Æ¬»úµÄflashÖĞ
  62   2              // |--Èç¹ûÃ»ÓĞÔòÖ±½ÓĞ´Èë£¬Èç¹ûÓĞÔò¸²¸Ç×î¾ÉµÄÆ÷¼şµØÖ·£¬ÔÙÒ»´ÎĞÔĞ´Èë
  63   2      
  64   2              // Í¨¹ıÑ­»·ÅĞ¶ÏflashÖĞÊÇ·ñÒÑ¾­ÓĞ¶ÔÓ¦µÄµØÖ·
  65   2              for (i = 0; i < ADDR_MAX_NUM; i++)
  66   2              {
  67   3                  if (addr_info.addr_buf[i] == (appear_themost_ele >> 8))
  68   3                  {
  69   4      #if USE_RF_UNPAIR // Èç¹û¿ªÆô È¡ÏûÅä¶Ô
              
                              // ÈôÆ÷¼şµØÖ·ÏàÍ¬£¬Çå³ı¶ÔÓ¦µÄÊı¾İ
                              addr_info.addr_buf[i] = 0;
                              addr_info.weighted_val_buf[i] = 0; // Çå³ıÈ¨Öµ
                              addr_info.remote_type[i] = 0;      // Çå³ıÒ£¿ØÆ÷ÀàĞÍ
              
                              // ½«Æ÷¼şµØÖ·Ğ´»Øflash
                              flash_erase_sector(FLASH_DEVICE_START_ADDR);
                              flash_write(FLASH_DEVICE_START_ADDR, (unsigned char *)(&addr_info), sizeof(addr_info));
              
                              return; // Ğ´ÈëÍê³É£¬º¯ÊıÖ±½Ó·µ»Ø
              
              #else // Èç¹ûÃ»ÓĞ¿ªÆô È¡ÏûÅä¶Ô
  83   4      
  84   4                      addr_info.weighted_val_buf[i] = 0;
  85   4                      addr_info.addr_buf[i] = (appear_themost_ele >> 8); // ±£´æµØÖ·ÕâÒ»²½¿ÉÒÔ²»ÓÃ¼Ó£¬ÒòÎª´ËÊ±µØ
             -Ö·ÊÇÏàÍ¬µÄ
  86   4      
  87   4                      if (0x01 == (appear_themost_ele & 0xFF))
  88   4                      {
  89   5                          // Èç¹ûÊÇ´óÒ¡¿ØÆ÷ÉÏÃæµÄµçÔ´°´¼ü/Ñ§Ï°°´¼ü
  90   5                          addr_info.remote_type[i] = REMOTE_TYPE_BIG_RM;
  91   5                      }
  92   4                      else if (0x03 == (appear_themost_ele & 0xFF))
  93   4                      {
  94   5                          // Èç¹ûÊÇĞ¡Ò£¿ØÆ÷ÉÏÃæµÄµçÔ´°´¼ü/Ñ§Ï°°´¼ü
  95   5                          addr_info.remote_type[i] = REMOTE_TYPE_SMALL_RM;
  96   5                      }
  97   4      
  98   4                      // Ôö¼ÓÆäËûµØÖ·µÄÈ¨Öµ£¨²»Ôö¼Ó¿ÕµÄµØÖ·µÄÈ¨Öµ£©
  99   4                      for (j = 0; j < ADDR_MAX_NUM; j++)
 100   4                      {
 101   5                          if ((j != i) && (addr_info.addr_buf[j] != 0))
 102   5                          {
 103   6                              addr_info.weighted_val_buf[j]++;
 104   6                          }
 105   5                      }
 106   4      
 107   4                      // ×îºó£¬½«Æ÷¼şµØÖ·Ğ´»Øflash
 108   4                      flash_erase_sector(FLASH_DEVICE_START_ADDR);
 109   4                      flash_write(FLASH_DEVICE_START_ADDR, (unsigned char *)(&addr_info), sizeof(addr_info));
 110   4                      return; // ½áÊøÑ§Ï°
 111   4      
 112   4      #endif // end if USE_RF_UNPAIR
C51 COMPILER V9.60.7.0   RF_LEARN                                                          11/08/2024 17:56:17 PAGE 3   

 113   4                  }
 114   3              }
 115   2      
 116   2              // Èç¹ûÒª±£´æµÄµØÖ·ÔÚflashÖĞ²¢Ã»ÓĞÖØ¸´
 117   2              // |---ÕÒÒ»´¦¿ÕµÄµØ·½±£´æ£¬Èç¹ûÃ»ÓĞ£¬Ôò¸²¸Ç×î¾ÉµÄÆ÷¼şµØÖ·
 118   2              for (i = 0; i < ADDR_MAX_NUM; i++)
 119   2              {
 120   3                  if ((addr_info.weighted_val_buf[i] == 0) && (addr_info.addr_buf[i] == 0))
 121   3                  {
 122   4                      // Èç¹ûÓĞ¿ÕµÄµØ·½£¬Ö±½Ó±£´æ
 123   4                      addr_info.weighted_val_buf[i] = 0;
 124   4                      addr_info.addr_buf[i] = (appear_themost_ele >> 8);
 125   4      
 126   4                      if (0x01 == (appear_themost_ele & 0xFF))
 127   4                      {
 128   5                          // Èç¹ûÊÇ´óÒ¡¿ØÆ÷ÉÏÃæµÄµçÔ´°´¼ü/Ñ§Ï°°´¼ü
 129   5                          addr_info.remote_type[i] = REMOTE_TYPE_BIG_RM;
 130   5                      }
 131   4                      else if (0x03 == (appear_themost_ele & 0xFF))
 132   4                      {
 133   5                          // Èç¹ûÊÇĞ¡Ò£¿ØÆ÷ÉÏÃæµÄµçÔ´°´¼ü/Ñ§Ï°°´¼ü
 134   5                          addr_info.remote_type[i] = REMOTE_TYPE_SMALL_RM;
 135   5                      }
 136   4      
 137   4                      // Ôö¼ÓÆäËûµØÖ·µÄÈ¨Öµ£¨²»Ôö¼Ó¿ÕµÄµØÖ·µÄÈ¨Öµ£©
 138   4                      for (j = 0; j < ADDR_MAX_NUM; j++)
 139   4                      {
 140   5                          if ((j != i) && (addr_info.addr_buf[j] != 0))
 141   5                          {
 142   6                              addr_info.weighted_val_buf[j]++;
 143   6                          }
 144   5                      }
 145   4      
 146   4                      isSpare = 1;
 147   4                      break;
 148   4                  }
 149   3              }
 150   2      
 151   2              // Èç¹ûÃ»ÓĞ¿ÕÓàµÄµØ·½£¬Ôò¸²¸Ç×î¾ÉµÄÆ÷¼şµØÖ·
 152   2              if (0 == isSpare)
 153   2              {
 154   3                  // Í¨¹ıÑ­»·ÕÒµ½×î¾ÉµÄµØÖ·ËùÔÚµÄÊı×éÏÂ±ê
 155   3                  for (i = 0; i < ADDR_MAX_NUM; i++)
 156   3                  {
 157   4                      if (addr_info.weighted_val_buf[i] > temp)
 158   4                      {
 159   5                          temp = addr_info.weighted_val_buf[i];
 160   5                          the_oldest_index = i;
 161   5                      }
 162   4                  }
 163   3      
 164   3                  addr_info.addr_buf[the_oldest_index] = (appear_themost_ele >> 8); // ±£´æÆ÷¼şµØÖ·
 165   3                  addr_info.weighted_val_buf[the_oldest_index] = 0;                 // È¨ÖµÉèÖÃÎª0
 166   3      
 167   3                  if (0x01 == (appear_themost_ele & 0xFF))
 168   3                  {
 169   4                      // Èç¹ûÊÇ´óÒ¡¿ØÆ÷ÉÏÃæµÄµçÔ´°´¼ü/Ñ§Ï°°´¼ü
 170   4                      addr_info.remote_type[the_oldest_index] = REMOTE_TYPE_BIG_RM;
 171   4                  }
 172   3                  else if (0x03 == (appear_themost_ele & 0xFF))
 173   3                  {
 174   4                      // Èç¹ûÊÇĞ¡Ò£¿ØÆ÷ÉÏÃæµÄµçÔ´°´¼ü/Ñ§Ï°°´¼ü
C51 COMPILER V9.60.7.0   RF_LEARN                                                          11/08/2024 17:56:17 PAGE 4   

 175   4                      addr_info.remote_type[the_oldest_index] = REMOTE_TYPE_SMALL_RM;
 176   4                  }
 177   3      
 178   3                  // Ôö¼ÓÆäËûµÄÆ÷¼şµØÖ·µÄÈ¨Öµ£¨ÕâÀïÒª¿¼ÂÇ²»Ôö¼Ó¿ÕµÄÆ÷¼şµØÖ·µÄÈ¨Öµ£©
 179   3                  for (j = 0; j < ADDR_MAX_NUM; j++)
 180   3                  {
 181   4                      if ((j != the_oldest_index) && (addr_info.addr_buf[j] != 0))
 182   4                      {
 183   5                          addr_info.weighted_val_buf[j]++;
 184   5                      }
 185   4                  }
 186   3              }
 187   2      
 188   2              // ×îºó£¬½«Æ÷¼şµØÖ·Ğ´»Øflash
 189   2              flash_erase_sector(FLASH_DEVICE_START_ADDR);
 190   2              flash_write(FLASH_DEVICE_START_ADDR, (unsigned char *)(&addr_info), sizeof(addr_info));
 191   2          }
 192   1      }
 193          
 194          // ÅĞ¶Ïµ±Ç°½ÓÊÕµÄÊı¾İµÄµØÖ·ÊÇ·ñÓëflashÖĞ±£´æµÄµØÖ·Æ¥Åä
 195          // ĞèÒªÏÈÑ§Ï°£¬´ÓflashÖĞ¶Á³öÊı¾İ
 196          // ·µ»Ø£º 0--²»Æ¥Åä£¬1--Æ¥Åä
 197          u8 rf_addr_isMatch(void)
 198          {
 199   1          u8 i = 0;
 200   1          for (i = 0; i < ADDR_MAX_NUM; i++)
 201   1          {
 202   2              if (addr_info.addr_buf[i] == (rf_data >> 8))
 203   2              {
 204   3                  return 1;
 205   3              }
 206   2          }
 207   1      
 208   1          return 0;
 209   1      }
 210          
 211          // ²âÊÔº¯Êı£¬²é¿´flashÖĞ°´²»Í¬µØÖ·À´±£´æµÄËùÓĞÆ÷¼şµØÖ·
 212          void show_addr_info_save_by_nums(void)
 213          {
 214   1          u32 i;
 215   1      
 216   1          for (i = 0; i < ADDR_MAX_NUM; i++)
 217   1          {
 218   2              send_keyval(addr_info.weighted_val_buf[i]);
 219   2              send_keyval(addr_info.addr_buf[i]);
 220   2          }
 221   1      }
 222          
 223          #endif // end of #ifdef LEARN_BY_QUANTITY
 224          
 225          #ifdef LEARN_BY_TYPE
              /**
               * @brief RFÑ§Ï°¹¦ÄÜ£¬5sÄÚ¼ì²âµ½ÓĞ°´¼ü³¤°´£¬Ôò½«Õâ¸öÒ£¿ØÆ÷µÄÆ÷¼şµØÖ·Ğ´Èëµ½flashÖĞ£¨Ò»°ã·ÅÔÚÉÏµçµÄ5sÖĞÊ¹ÓÃ£
             -©
               *          Èç¹û my_config.hÎÄ¼şÖĞµÄUSE_RF_UNPAIRÎª1£¬ÄÇÃ´µ±ÊÕµ½ÓĞÓëflashÖĞÏàÍ¬µÄÆ÷¼şµØÖ·´«À´µÄĞÅºÅÊ±£¬
               *          »á´ÓflashÖĞÉ¾³ı¸ÃµØÖ·Êı¾İ£¬ÊµÏÖÈ¡ÏûÅä¶Ô
               */
              void rf_learn(void)
              {
                  u32 appear_themost_ele = 0; // RF½ÓÊÕÊı×éÖĞ³öÏÖ×î¶à´ÎÊıµÄÔªËØ
              
                  int32 i = 0; // Ñ­»·¼ÆÊıÖµ
C51 COMPILER V9.60.7.0   RF_LEARN                                                          11/08/2024 17:56:17 PAGE 5   

                  int32 j = 0; // Ñ­»·¼ÆÊıÖµ
              
                  u8 isExist = 0; // ±êÖ¾Î»£¬µØÖ·ÊÇ·ñÒÑ¾­ÔÚflash±£´æ
                  u8 isSpare = 0; // ±êÖ¾Î»£¬±êÖ¾´æ·ÅµØÖ·µÄÈİÆ÷ÖĞÊÇ·ñÓĞ¿ÕµÄµØ·½
              
                  u32 temp = 0;             // ´æ·ÅÁÙÊ±Öµ
                  u32 the_oldest_index = 0; // ×î¾ÉµÄÆ÷¼şµØÖ·¶ÔÓ¦µÄÊı×éÏÂ±ê
              
                  // ´ò¿ª¶¨Ê±Æ÷
                  tmr2_enable();
              
                  while (tmr2_flag != 1)
                  {
                      WDT_KEY = WDT_KEY_VAL(0xAA); // Î¹¹·
                      rf_recv_databuf();           // Ã¿´ÎÑ­»·£¬ÊÔ×Å¶ÁÈ¡Ò»´ÎÊı¾İ
                  }
              
                  // 5sºó£¬¹Ø±Õ¶¨Ê±Æ÷£¬Çå¿ÕËüÓ²¼şµÄ¼ÆÊıÖµ
                  tmr2_disable();
                  tmr2_flag = 0; // Çå³ı±êÖ¾Î»
                  tmr2_cnt = 0;  // Çå³ı¶¨Ê±Æ÷µÄ¼ÆÊıÖµ
              
                  // ´ÓflashÖĞ¶ÁÈ¡Æ÷¼şµØÖ·
                  flash_read(FLASH_DEVICE_START_ADDR, (unsigned char *)(&addr_info), sizeof(addr_info));
              
                  // Èç¹ûÕâ¶ÎÊ±¼äÄÚ£¨5sÄÚ£©¼ì²âµ½ÓĞ°´¼ü³¤°´£¬Ê¹µÃ±êÖ¾Î»ÖÃÒ»£¬½øĞĞÏà¹ØµÄ´¦Àí
                  if (rf_data_buf_overflow)
                  {
                      rf_data_buf_overflow = 0;
                      // ÕÒ³öÊı×éÖĞ³öÏÖ´ÎÊı×î¶àµÄÔªËØ
                      appear_themost(rf_data_buf, sizeof(rf_data_buf) / sizeof(rf_data_buf[0]), &appear_themost_ele, NUL
             -L);
              
                      // Èç¹û²»ÊÇµçÔ´°´¼ü£¬º¯ÊıÍË³ö£¨´ı²¹³ä£©
              
                      // Èç¹ûÊÇµçÔ´°´¼ü
                      // ½«Æ÷¼şµØÖ·Ğ´Èëµ½µ¥Æ¬»úµÄflashÖĞ
                      // |--Èç¹ûÃ»ÓĞÔòÖ±½ÓĞ´Èë£¬Èç¹ûÓĞÔò¸²¸Ç×î¾ÉµÄÆ÷¼şµØÖ·£¬ÔÙÒ»´ÎĞÔĞ´Èë
                      for (i = 0; i < ADDR_MAX_TYPE_NUM; i++)
                      {
                          if (addr_info.type_buf[i] == (appear_themost_ele & 0xFF))
                          {
                              // Èç¹ûflashÖĞÒÑ¾­ÓĞ¶ÔÓ¦ÀàĞÍµÄÆ÷¼şµØÖ·
                              isExist = 1;
                              break;
                          }
                      }
              
                      if (isExist)
                      {
                          // Èç¹ûflashÖĞÒÑ¾­ÓĞ¶ÔÓ¦ÀàĞÍµÄÆ÷¼şµØÖ·
                          // ÅĞ¶ÏÆ÷¼şµØÖ·ÊÇ·ñÏàÍ¬
                          if (addr_info.addr_buf[i] == (appear_themost_ele >> 8))
                          {
              #if USE_RF_UNPAIR // Èç¹ûÊ¹ÓÃÁËÈ¡ÏûÅä¶Ô
              
                              // ÈôÆ÷¼şµØÖ·ÏàÍ¬£¬Çå³ı¶ÔÓ¦µÄÊı¾İ
                              addr_info.addr_buf[i] = 0;
                              addr_info.type_buf[i] = 0;
                              addr_info.weighted_val_buf[i] = 0;
              
                              // ½«Æ÷¼şµØÖ·Ğ´»Øflash
C51 COMPILER V9.60.7.0   RF_LEARN                                                          11/08/2024 17:56:17 PAGE 6   

                              flash_erase_sector(FLASH_DEVICE_START_ADDR);
                              flash_write(FLASH_DEVICE_START_ADDR, (unsigned char *)(&addr_info), sizeof(addr_info));
              
                              return; // Ğ´ÈëÍê³Éºó£¬º¯Êı¿ÉÒÔÖ±½Ó·µ»ØÁË
              
              #else // Èç¹û²»Ê¹ÓÃÈ¡ÏûÅä¶Ô
              
                              // ÈôÆ÷¼şµØÖ·ÏàÍ¬Ôò²»ÓÃ¸²¸Ç£¬Ö±½ÓÍË³ö
                              return;
              
              #endif // end if USE_RF_UNPAIR
                          }
              
                          addr_info.addr_buf[i] = (appear_themost_ele >> 8); // ¸²¸ÇÆ÷¼şµØÖ·
                          addr_info.weighted_val_buf[i] = 0;                 // È¨ÖµÉèÖÃÎª0£¬±íÊ¾ËüÊÇ×îĞÂĞ´ÈëµÄ
              
                          // Ôö¼ÓÆäËûÀàĞÍµÄÆ÷¼şµØÖ·µÄÈ¨Öµ£¨ÕâÀïÒª¿¼ÂÇ²»Ôö¼Ó¿ÕµÄÆ÷¼şµØÖ·µÄÈ¨Öµ£©
                          for (j = 0; j < ADDR_MAX_TYPE_NUM; j++)
                          {
                              if ((j != i) && (addr_info.addr_buf[j] != 0))
                              {
                                  addr_info.weighted_val_buf[j]++;
                              }
                          }
                      }
                      else
                      {
                          // Èç¹ûflashÖĞÃ»ÓĞ¶ÔÓ¦ÀàĞÍµÄÆ÷¼şµØÖ·£¬ÔòÕÒÒ»´¦¿ÕµÄµØ·½£¬±£´æ
                          // Èç¹ûÃ»ÓĞ¿ÕµÄµØ·½£¬¸²¸Ç×î¾ÉµÄÀàĞÍºÍÆ÷¼şµØÖ·
              
                          for (i = 0; i < ADDR_MAX_TYPE_NUM; i++)
                          {
                              if ((addr_info.type_buf[i] == 0) && (addr_info.addr_buf[i] == 0) && (addr_info.weighted_va
             -l_buf[i] == 0))
                              {
                                  // Èç¹ûÓĞ¿ÕµÄµØ·½
                                  addr_info.type_buf[i] = (appear_themost_ele & 0xFF); // ¼üÖµ×÷ÎªÆ÷¼şÀàĞÍ£¬±£´æÆğÀ´
                                  addr_info.addr_buf[i] = (appear_themost_ele >> 8);   // ±£´æÆ÷¼şµØÖ·
                                  addr_info.weighted_val_buf[i] = 0;                   // È¨ÖµÉèÖÃÎª0£¬±íÊ¾ËüÊÇ×îĞÂĞ´Èëµ
             -Ä
              
                                  // Ôö¼ÓÆäËûÀàĞÍµÄÆ÷¼şµØÖ·µÄÈ¨Öµ£¨ÕâÀïÒª¿¼ÂÇ²»Ôö¼Ó¿ÕµÄÆ÷¼şµØÖ·µÄÈ¨Öµ£©
                                  for (j = 0; j < ADDR_MAX_TYPE_NUM; j++)
                                  {
                                      if ((j != i) && (addr_info.addr_buf[j] != 0))
                                      {
                                          addr_info.weighted_val_buf[j]++;
                                      }
                                  }
                                  isSpare = 1; // ÓĞ¿ÕÓàµÄµØ·½£¬²¢ÇÒÒÑ¾­Íê³É±£´æ
                                  break;
                              }
                          }
              
                          // Èç¹ûÃ»ÓĞ¿ÕÓàµÄµØ·½£¬Ôò¸²¸Ç×î¾ÉµÄÀàĞÍºÍÆ÷¼şµØÖ·
                          if (0 == isSpare)
                          {
                              // Í¨¹ıÑ­»·ÕÒµ½×î¾ÉµÄÀàĞÍËùÔÚµÄÊı×éÏÂ±ê
                              for (i = 0; i < ADDR_MAX_TYPE_NUM; i++)
                              {
                                  if (addr_info.weighted_val_buf[i] > temp)
                                  {
C51 COMPILER V9.60.7.0   RF_LEARN                                                          11/08/2024 17:56:17 PAGE 7   

                                      temp = addr_info.weighted_val_buf[i];
                                      the_oldest_index = i;
                                  }
                              }
              
                              addr_info.type_buf[the_oldest_index] = (appear_themost_ele & 0xFF); // ¼üÖµ×÷ÎªÆ÷¼şÀàĞÍ
                              addr_info.addr_buf[the_oldest_index] = (appear_themost_ele >> 8);   // ±£´æÆ÷¼şµØÖ·
                              addr_info.weighted_val_buf[the_oldest_index] = 0;
              
                              // Ôö¼ÓÆäËûÀàĞÍµÄÆ÷¼şµØÖ·µÄÈ¨Öµ£¨ÕâÀïÒª¿¼ÂÇ²»Ôö¼Ó¿ÕµÄÆ÷¼şµØÖ·µÄÈ¨Öµ£©
                              for (j = 0; j < ADDR_MAX_TYPE_NUM; j++)
                              {
                                  if ((j != the_oldest_index) && (addr_info.addr_buf[j] != 0))
                                  {
                                      addr_info.weighted_val_buf[j]++;
                                  }
                              }
                          }
                      }
              
                      // ½«Æ÷¼şµØÖ·Ğ´»Øflash
                      flash_erase_sector(FLASH_DEVICE_START_ADDR);
                      flash_write(FLASH_DEVICE_START_ADDR, (unsigned char *)(&addr_info), sizeof(addr_info));
                  }
              }
              
              // ÅĞ¶Ïµ±Ç°½ÓÊÕµÄÊı¾İµÄµØÖ·ÊÇ·ñÓëflashÖĞ±£´æµÄµØÖ·Æ¥Åä
              // ĞèÒªÏÈÑ§Ï°£¬´ÓflashÖĞ¶Á³öÊı¾İ
              // ·µ»Ø£º 0--²»Æ¥Åä£¬1--Æ¥Åä
              u8 rf_addr_isMatch(void)
              {
                  u32 i = 0;
                  for (i = 0; i < ADDR_MAX_TYPE_NUM; i++)
                  {
                      if (addr_info.addr_buf[i] == (rf_data >> 8))
                      {
                          return 1;
                      }
                  }
              
                  return 0;
              }
              
              // ²âÊÔº¯Êı£¬²é¿´flashÖĞ°´Æ÷¼şÀàĞÍÀ´±£´æµÄÆ÷¼şµØÖ·
              void show_addr_info_save_by_type(void)
              {
                  u32 i;
              
                  for (i = 0; i < ADDR_MAX_TYPE_NUM; i++)
                  {
                      send_keyval(addr_info.weighted_val_buf[i]);
                      send_keyval(addr_info.type_buf[i]);
                      send_keyval(addr_info.addr_buf[i]);
                  }
              }
              
              #endif // end ifdef LEARN_BY_TYPE


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1869    ----
   CONSTANT SIZE    =   ----    ----
C51 COMPILER V9.60.7.0   RF_LEARN                                                          11/08/2024 17:56:17 PAGE 8   

   XDATA SIZE       =     12      25
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
