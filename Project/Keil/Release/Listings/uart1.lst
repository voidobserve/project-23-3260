C51 COMPILER V9.60.7.0   UART1                                                             11/13/2024 17:38:41 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE UART1
OBJECT MODULE PLACED IN .\Release\Objects\uart1.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\Hardware\uart1.c LARGE OPTIMIZE(8,SPEED) BROWSE INTVECTOR(0X000C) 
                    -INCDIR(..\..\Libraries\Include;..\..\Hardware;..\..\User;..\..\User\lib) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\
                    -Listings\uart1.lst) OBJECT(.\Release\Objects\uart1.obj)

line level    source

   1          #include "uart1.h"
   2          #include <string.h>
   3          
   4          #define UART1_BAUD (115200UL)
   5          #define USER_UART1_BAUD ((SYSCLK - UART1_BAUD) / (UART1_BAUD))
   6          
   7          #define PROTOCOL_HEAD ((u8)0xA5) // 协议头
   8          #define PROTOCOL_TAIL ((u8)0x5A) // 协议尾
   9          
  10          volatile u8 flag_cur_recv_status = CUR_RECV_STATUS_NONE; // 当前接收的状态(作为状态机)
  11          
  12          // 定义存放指令的结构体变量，0xFF表示无效的指令，会清空显示
  13          volatile instruction_t instruction = {
  14              0xFF, // seg1
  15              0xFF, // seg2
  16              0xFF, // point
  17              0xFF, // led
  18          };
  19          
  20          void uart1_config(void)
  21          {
  22   1          P1_MD0 &= ~(GPIO_P12_MODE_SEL(0x3)); // 配置为输入模式
  23   1          FIN_S8 |= GPIO_FIN_SEL_P12;          // uart1_rx 输入功能 pin 脚选择
  24   1      
  25   1          __EnableIRQ(UART1_IRQn); // 打开UART模块中断
  26   1          IE_EA = 1;               // 打开总中断
  27   1      
  28   1          UART1_BAUD1 = (USER_UART1_BAUD >> 8) & 0xFF; // 配置波特率高八位
  29   1          UART1_BAUD0 = USER_UART1_BAUD & 0xFF;        // 配置波特率低八位
  30   1          UART1_CON0 = UART_STOP_BIT(0x0) |            // 8bit数据，1bit停止位，使能中断
  31   1                       UART_RX_IRQ_EN(0x1) |
  32   1                       UART_EN(0x1);
  33   1      }
  34          
  35          void uart1_recv_err_handle(void)
  36          {
  37   1          if (CUR_RECV_STATUS_ERR == flag_cur_recv_status)
  38   1          {
  39   2              // 如果接收协议头和协议尾出错
  40   2              memset(&instruction, 0xFF, sizeof(instruction));
  41   2              memset(aip650_show_buff, 0x00, ARRAY_SIZE(aip650_show_buff));
  42   2              aip650_show_refresh();
  43   2      
  44   2      #if USE_MY_DEBUG
  45   2              printf("recv err\n");
  46   2      #endif
  47   2      
  48   2              flag_cur_recv_status = CUR_RECV_STATUS_NONE;
  49   2          }
  50   1      
  51   1          if (tmr0_cnt >= 10)
  52   1          {
  53   2              // 接收到协议头后，超过10ms没有收到数据
C51 COMPILER V9.60.7.0   UART1                                                             11/13/2024 17:38:41 PAGE 2   

  54   2              memset(&instruction, 0xFF, sizeof(instruction));
  55   2              memset(aip650_show_buff, 0x00, ARRAY_SIZE(aip650_show_buff));
  56   2              aip650_show_refresh();
  57   2              flag_cur_recv_status = CUR_RECV_STATUS_NONE;
  58   2              tmr0_disable();
  59   2              tmr0_cnt = 0;
  60   2      
  61   2      #if USE_MY_DEBUG
  62   2              printf("recv time out\n");
  63   2      #endif
  64   2          }
  65   1      
  66   1          // printf("tmr0 cnt %d\n", (u16)tmr0_cnt);
  67   1      }
  68          
  69          void UART1_IRQHandler(void) interrupt UART1_IRQn
  70          {
  71   1          u8 uart_data = 0;
  72   1      
  73   1          // 进入中断设置IP，不可删除
  74   1          __IRQnIPnPush(UART1_IRQn);
  75   1      
  76   1          // ---------------- 用户函数处理 -------------------
  77   1      
  78   1          // RX接收完成中断
  79   1          if (UART1_STA & UART_RX_DONE(0x1))
  80   1          {
  81   2              uart_data = UART1_DATA;
  82   2              tmr0_cnt = 0; // 每次接收到数据，清空超时计数
  83   2              tmr0_enable();
  84   2      
  85   2              if (flag_cur_recv_status == CUR_RECV_STATUS_NONE &&
  86   2                  uart_data == PROTOCOL_HEAD)
  87   2              {
  88   3                  // 协议头
  89   3                  flag_cur_recv_status = CUR_RECV_STATUS_SEG1;
  90   3                  // tmr0_cnt = 0;
  91   3                  // tmr0_enable();
  92   3              }
  93   2              else if (flag_cur_recv_status == CUR_RECV_STATUS_SEG1)
  94   2              {
  95   3                  // 接收控制数码管1的数据
  96   3                  instruction.seg1 = uart_data;
  97   3                  flag_cur_recv_status = CUR_RECV_STATUS_SEG2;
  98   3              }
  99   2              else if (flag_cur_recv_status == CUR_RECV_STATUS_SEG2)
 100   2              {
 101   3                  // 接收控制数码管2的数据
 102   3                  instruction.seg2 = uart_data;
 103   3                  flag_cur_recv_status = CUR_RECV_STATUS_POINT;
 104   3              }
 105   2              else if (flag_cur_recv_status == CUR_RECV_STATUS_POINT)
 106   2              {
 107   3                  // 接收控制小数点显示的数据
 108   3                  instruction.point = uart_data;
 109   3                  flag_cur_recv_status = CUR_RECV_STATUS_LED;
 110   3              }
 111   2              else if (flag_cur_recv_status == CUR_RECV_STATUS_LED)
 112   2              {
 113   3                  // 接收控制触摸按键对应的LED的数据
 114   3                  instruction.led = uart_data;
 115   3                  flag_cur_recv_status = CUR_RECV_STATUS_END;
C51 COMPILER V9.60.7.0   UART1                                                             11/13/2024 17:38:41 PAGE 3   

 116   3              }
 117   2              else if (flag_cur_recv_status == CUR_RECV_STATUS_END &&
 118   2                       uart_data == PROTOCOL_TAIL)
 119   2              {
 120   3                  // 协议尾
 121   3                  flag_cur_recv_status = CUR_RECV_STATUS_COMPLETE; // 表示完成接收
 122   3                  tmr0_disable();
 123   3                  tmr0_cnt = 0;
 124   3              }
 125   2              else
 126   2              {
 127   3                  // 如果接收错误(这里只能检测到第一个字节和最后一个字节的数据错误
             -)
 128   3                  // 切换到对应的状态，由uart1_recv_err_handle()函数处理
 129   3                  flag_cur_recv_status = CUR_RECV_STATUS_ERR;
 130   3      
 131   3                  tmr0_disable();
 132   3                  tmr0_cnt = 0;
 133   3      
 134   3      #if USE_MY_DEBUG
 135   3                  // printf("recv err\n");
 136   3      #endif
 137   3              }
 138   2          }
 139   1      
 140   1          // 退出中断设置IP，不可删除
 141   1          __IRQnIPnPop(UART1_IRQn);
 142   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    406    ----
   CONSTANT SIZE    =     25    ----
   XDATA SIZE       =      5       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
